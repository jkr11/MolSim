// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "checkpoint-schema.hxx"

#include <xsd/cxx/pre.hxx>

// CheckpointType
//

const CheckpointType::Particles_type& CheckpointType::Particles() const {
  return this->Particles_.get();
}

CheckpointType::Particles_type& CheckpointType::Particles() {
  return this->Particles_.get();
}

void CheckpointType::Particles(const Particles_type& x) {
  this->Particles_.set(x);
}

void CheckpointType::Particles(::std::auto_ptr<Particles_type> x) {
  this->Particles_.set(x);
}

// ParticlesType
//

const ParticlesType::Particle_sequence& ParticlesType::Particle() const {
  return this->Particle_;
}

ParticlesType::Particle_sequence& ParticlesType::Particle() {
  return this->Particle_;
}

void ParticlesType::Particle(const Particle_sequence& s) {
  this->Particle_ = s;
}

// ParticleType
//

const ParticleType::Position_type& ParticleType::Position() const {
  return this->Position_.get();
}

ParticleType::Position_type& ParticleType::Position() {
  return this->Position_.get();
}

void ParticleType::Position(const Position_type& x) { this->Position_.set(x); }

void ParticleType::Position(::std::auto_ptr<Position_type> x) {
  this->Position_.set(x);
}

const ParticleType::Velocity_type& ParticleType::Velocity() const {
  return this->Velocity_.get();
}

ParticleType::Velocity_type& ParticleType::Velocity() {
  return this->Velocity_.get();
}

void ParticleType::Velocity(const Velocity_type& x) { this->Velocity_.set(x); }

void ParticleType::Velocity(::std::auto_ptr<Velocity_type> x) {
  this->Velocity_.set(x);
}

const ParticleType::Force_type& ParticleType::Force() const {
  return this->Force_.get();
}

ParticleType::Force_type& ParticleType::Force() { return this->Force_.get(); }

void ParticleType::Force(const Force_type& x) { this->Force_.set(x); }

void ParticleType::Force(::std::auto_ptr<Force_type> x) { this->Force_.set(x); }

const ParticleType::OldForce_type& ParticleType::OldForce() const {
  return this->OldForce_.get();
}

ParticleType::OldForce_type& ParticleType::OldForce() {
  return this->OldForce_.get();
}

void ParticleType::OldForce(const OldForce_type& x) { this->OldForce_.set(x); }

void ParticleType::OldForce(::std::auto_ptr<OldForce_type> x) {
  this->OldForce_.set(x);
}

const ParticleType::mass_type& ParticleType::mass() const {
  return this->mass_.get();
}

ParticleType::mass_type& ParticleType::mass() { return this->mass_.get(); }

void ParticleType::mass(const mass_type& x) { this->mass_.set(x); }

const ParticleType::epsilon_type& ParticleType::epsilon() const {
  return this->epsilon_.get();
}

ParticleType::epsilon_type& ParticleType::epsilon() {
  return this->epsilon_.get();
}

void ParticleType::epsilon(const epsilon_type& x) { this->epsilon_.set(x); }

const ParticleType::sigma_type& ParticleType::sigma() const {
  return this->sigma_.get();
}

ParticleType::sigma_type& ParticleType::sigma() { return this->sigma_.get(); }

void ParticleType::sigma(const sigma_type& x) { this->sigma_.set(x); }

const ParticleType::type_type& ParticleType::type() const {
  return this->type_.get();
}

ParticleType::type_type& ParticleType::type() { return this->type_.get(); }

void ParticleType::type(const type_type& x) { this->type_.set(x); }

// CDvec3Type
//

const CDvec3Type::x_type& CDvec3Type::x() const { return this->x_.get(); }

CDvec3Type::x_type& CDvec3Type::x() { return this->x_.get(); }

void CDvec3Type::x(const x_type& x) { this->x_.set(x); }

const CDvec3Type::y_type& CDvec3Type::y() const { return this->y_.get(); }

CDvec3Type::y_type& CDvec3Type::y() { return this->y_.get(); }

void CDvec3Type::y(const y_type& x) { this->y_.set(x); }

const CDvec3Type::z_type& CDvec3Type::z() const { return this->z_.get(); }

CDvec3Type::z_type& CDvec3Type::z() { return this->z_.get(); }

void CDvec3Type::z(const z_type& x) { this->z_.set(x); }

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// CheckpointType
//

CheckpointType::CheckpointType(const Particles_type& Particles)
    : ::xml_schema::type(), Particles_(Particles, this) {}

CheckpointType::CheckpointType(::std::auto_ptr<Particles_type> Particles)
    : ::xml_schema::type(), Particles_(Particles, this) {}

CheckpointType::CheckpointType(const CheckpointType& x, ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), Particles_(x.Particles_, f, this) {}

CheckpointType::CheckpointType(const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      Particles_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void CheckpointType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Particles
    //
    if (n.name() == "Particles" && n.namespace_().empty()) {
      ::std::auto_ptr<Particles_type> r(Particles_traits::create(i, f, this));

      if (!Particles_.present()) {
        this->Particles_.set(r);
        continue;
      }
    }

    break;
  }

  if (!Particles_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("Particles", "");
  }
}

CheckpointType* CheckpointType::_clone(::xml_schema::flags f,
                                       ::xml_schema::container* c) const {
  return new class CheckpointType(*this, f, c);
}

CheckpointType& CheckpointType::operator=(const CheckpointType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Particles_ = x.Particles_;
  }

  return *this;
}

CheckpointType::~CheckpointType() {}

// ParticlesType
//

ParticlesType::ParticlesType() : ::xml_schema::type(), Particle_(this) {}

ParticlesType::ParticlesType(const ParticlesType& x, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), Particle_(x.Particle_, f, this) {}

ParticlesType::ParticlesType(const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), Particle_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ParticlesType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Particle
    //
    if (n.name() == "Particle" && n.namespace_().empty()) {
      ::std::auto_ptr<Particle_type> r(Particle_traits::create(i, f, this));

      this->Particle_.push_back(r);
      continue;
    }

    break;
  }
}

ParticlesType* ParticlesType::_clone(::xml_schema::flags f,
                                     ::xml_schema::container* c) const {
  return new class ParticlesType(*this, f, c);
}

ParticlesType& ParticlesType::operator=(const ParticlesType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Particle_ = x.Particle_;
  }

  return *this;
}

ParticlesType::~ParticlesType() {}

// ParticleType
//

ParticleType::ParticleType(const Position_type& Position,
                           const Velocity_type& Velocity,
                           const Force_type& Force,
                           const OldForce_type& OldForce, const mass_type& mass,
                           const epsilon_type& epsilon, const sigma_type& sigma,
                           const type_type& type)
    : ::xml_schema::type(),
      Position_(Position, this),
      Velocity_(Velocity, this),
      Force_(Force, this),
      OldForce_(OldForce, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      type_(type, this) {}

ParticleType::ParticleType(::std::auto_ptr<Position_type> Position,
                           ::std::auto_ptr<Velocity_type> Velocity,
                           ::std::auto_ptr<Force_type> Force,
                           ::std::auto_ptr<OldForce_type> OldForce,
                           const mass_type& mass, const epsilon_type& epsilon,
                           const sigma_type& sigma, const type_type& type)
    : ::xml_schema::type(),
      Position_(Position, this),
      Velocity_(Velocity, this),
      Force_(Force, this),
      OldForce_(OldForce, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      type_(type, this) {}

ParticleType::ParticleType(const ParticleType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      Position_(x.Position_, f, this),
      Velocity_(x.Velocity_, f, this),
      Force_(x.Force_, f, this),
      OldForce_(x.OldForce_, f, this),
      mass_(x.mass_, f, this),
      epsilon_(x.epsilon_, f, this),
      sigma_(x.sigma_, f, this),
      type_(x.type_, f, this) {}

ParticleType::ParticleType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      Position_(this),
      Velocity_(this),
      Force_(this),
      OldForce_(this),
      mass_(this),
      epsilon_(this),
      sigma_(this),
      type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ParticleType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Position
    //
    if (n.name() == "Position" && n.namespace_().empty()) {
      ::std::auto_ptr<Position_type> r(Position_traits::create(i, f, this));

      if (!Position_.present()) {
        this->Position_.set(r);
        continue;
      }
    }

    // Velocity
    //
    if (n.name() == "Velocity" && n.namespace_().empty()) {
      ::std::auto_ptr<Velocity_type> r(Velocity_traits::create(i, f, this));

      if (!Velocity_.present()) {
        this->Velocity_.set(r);
        continue;
      }
    }

    // Force
    //
    if (n.name() == "Force" && n.namespace_().empty()) {
      ::std::auto_ptr<Force_type> r(Force_traits::create(i, f, this));

      if (!Force_.present()) {
        this->Force_.set(r);
        continue;
      }
    }

    // OldForce
    //
    if (n.name() == "OldForce" && n.namespace_().empty()) {
      ::std::auto_ptr<OldForce_type> r(OldForce_traits::create(i, f, this));

      if (!OldForce_.present()) {
        this->OldForce_.set(r);
        continue;
      }
    }

    // mass
    //
    if (n.name() == "mass" && n.namespace_().empty()) {
      if (!mass_.present()) {
        this->mass_.set(mass_traits::create(i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name() == "epsilon" && n.namespace_().empty()) {
      if (!epsilon_.present()) {
        this->epsilon_.set(epsilon_traits::create(i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name() == "sigma" && n.namespace_().empty()) {
      if (!sigma_.present()) {
        this->sigma_.set(sigma_traits::create(i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name() == "type" && n.namespace_().empty()) {
      if (!type_.present()) {
        this->type_.set(type_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Position_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("Position", "");
  }

  if (!Velocity_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("Velocity", "");
  }

  if (!Force_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("Force", "");
  }

  if (!OldForce_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("OldForce", "");
  }

  if (!mass_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mass", "");
  }

  if (!epsilon_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("epsilon", "");
  }

  if (!sigma_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("sigma", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("type", "");
  }
}

ParticleType* ParticleType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class ParticleType(*this, f, c);
}

ParticleType& ParticleType::operator=(const ParticleType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Position_ = x.Position_;
    this->Velocity_ = x.Velocity_;
    this->Force_ = x.Force_;
    this->OldForce_ = x.OldForce_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->type_ = x.type_;
  }

  return *this;
}

ParticleType::~ParticleType() {}

// CDvec3Type
//

CDvec3Type::CDvec3Type(const x_type& x, const y_type& y, const z_type& z)
    : ::xml_schema::type(), x_(x, this), y_(y, this), z_(z, this) {}

CDvec3Type::CDvec3Type(const CDvec3Type& x, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      x_(x.x_, f, this),
      y_(x.y_, f, this),
      z_(x.z_, f, this) {}

CDvec3Type::CDvec3Type(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      x_(this),
      y_(this),
      z_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void CDvec3Type::parse(::xsd::cxx::xml::dom::parser<char>& p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // x
    //
    if (n.name() == "x" && n.namespace_().empty()) {
      if (!x_.present()) {
        this->x_.set(x_traits::create(i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name() == "y" && n.namespace_().empty()) {
      if (!y_.present()) {
        this->y_.set(y_traits::create(i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name() == "z" && n.namespace_().empty()) {
      if (!z_.present()) {
        this->z_.set(z_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x", "");
  }

  if (!y_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y", "");
  }

  if (!z_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z", "");
  }
}

CDvec3Type* CDvec3Type::_clone(::xml_schema::flags f,
                               ::xml_schema::container* c) const {
  return new class CDvec3Type(*this, f, c);
}

CDvec3Type& CDvec3Type::operator=(const CDvec3Type& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

CDvec3Type::~CDvec3Type() {}

#include <istream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/sax/std-input-source.hxx>

::std::auto_ptr< ::CheckpointType> Checkpoint(
    const ::std::string& u, ::xml_schema::flags f,
    const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::auto_ptr< ::CheckpointType>(
      ::Checkpoint(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    const ::std::string& u, ::xml_schema::error_handler& h,
    ::xml_schema::flags f, const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::CheckpointType>(
      ::Checkpoint(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    const ::std::string& u, ::xercesc::DOMErrorHandler& h,
    ::xml_schema::flags f, const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::CheckpointType>(
      ::Checkpoint(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::std::istream& is, ::xml_schema::flags f,
    const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::Checkpoint(isrc, f, p);
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::std::istream& is, ::xml_schema::error_handler& h, ::xml_schema::flags f,
    const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::Checkpoint(isrc, h, f, p);
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::std::istream& is, ::xercesc::DOMErrorHandler& h, ::xml_schema::flags f,
    const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::Checkpoint(isrc, h, f, p);
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::std::istream& is, const ::std::string& sid, ::xml_schema::flags f,
    const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::Checkpoint(isrc, f, p);
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::std::istream& is, const ::std::string& sid,
    ::xml_schema::error_handler& h, ::xml_schema::flags f,
    const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::Checkpoint(isrc, h, f, p);
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::std::istream& is, const ::std::string& sid, ::xercesc::DOMErrorHandler& h,
    ::xml_schema::flags f, const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::Checkpoint(isrc, h, f, p);
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::xercesc::InputSource& i, ::xml_schema::flags f,
    const ::xml_schema::properties& p) {
  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::auto_ptr< ::CheckpointType>(
      ::Checkpoint(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::xercesc::InputSource& i, ::xml_schema::error_handler& h,
    ::xml_schema::flags f, const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::CheckpointType>(
      ::Checkpoint(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::xercesc::InputSource& i, ::xercesc::DOMErrorHandler& h,
    ::xml_schema::flags f, const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::CheckpointType>(
      ::Checkpoint(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    const ::xercesc::DOMDocument& doc, ::xml_schema::flags f,
    const ::xml_schema::properties& p) {
  if (f & ::xml_schema::flags::keep_dom) {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
        static_cast< ::xercesc::DOMDocument*>(doc.cloneNode(true)));

    return ::std::auto_ptr< ::CheckpointType>(
        ::Checkpoint(d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e(*doc.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "Checkpoint" && n.namespace_() == "") {
    ::std::auto_ptr< ::CheckpointType> r(
        ::xsd::cxx::tree::traits< ::CheckpointType, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "Checkpoint", "");
}

::std::auto_ptr< ::CheckpointType> Checkpoint(
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d,
    ::xml_schema::flags f, const ::xml_schema::properties&) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> c(
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument*>(d->cloneNode(true))
          : 0);

  ::xercesc::DOMDocument& doc(c.get() ? *c : *d);
  const ::xercesc::DOMElement& e(*doc.getDocumentElement());

  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData(::xml_schema::dom::tree_node_key, (c.get() ? &c : &d), 0);

  if (n.name() == "Checkpoint" && n.namespace_() == "") {
    ::std::auto_ptr< ::CheckpointType> r(
        ::xsd::cxx::tree::traits< ::CheckpointType, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "Checkpoint", "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void Checkpoint(::std::ostream& o, const ::CheckpointType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e, ::xml_schema::flags f) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(::Checkpoint(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed< ::xsd::cxx::tree::serialization<char> >();
  }
}

void Checkpoint(::std::ostream& o, const ::CheckpointType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e, ::xml_schema::flags f) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(::Checkpoint(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void Checkpoint(::std::ostream& o, const ::CheckpointType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e, ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(::Checkpoint(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void Checkpoint(::xercesc::XMLFormatTarget& t, const ::CheckpointType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e, ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(::Checkpoint(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed< ::xsd::cxx::tree::serialization<char> >();
  }
}

void Checkpoint(::xercesc::XMLFormatTarget& t, const ::CheckpointType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e, ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(::Checkpoint(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void Checkpoint(::xercesc::XMLFormatTarget& t, const ::CheckpointType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e, ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(::Checkpoint(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void Checkpoint(::xercesc::DOMDocument& d, const ::CheckpointType& s,
                ::xml_schema::flags) {
  ::xercesc::DOMElement& e(*d.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "Checkpoint" && n.namespace_() == "") {
    e << s;
  } else {
    throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                     "Checkpoint", "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> Checkpoint(
    const ::CheckpointType& s, const ::xml_schema::namespace_infomap& m,
    ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::serialize<char>("Checkpoint", "", m, f));

  ::Checkpoint(*d, s, f);
  return d;
}

void operator<<(::xercesc::DOMElement& e, const CheckpointType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // Particles
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("Particles", e));

    s << i.Particles();
  }
}

void operator<<(::xercesc::DOMElement& e, const ParticlesType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // Particle
  //
  for (ParticlesType::Particle_const_iterator b(i.Particle().begin()),
       n(i.Particle().end());
       b != n; ++b) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("Particle", e));

    s << *b;
  }
}

void operator<<(::xercesc::DOMElement& e, const ParticleType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // Position
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("Position", e));

    s << i.Position();
  }

  // Velocity
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("Velocity", e));

    s << i.Velocity();
  }

  // Force
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("Force", e));

    s << i.Force();
  }

  // OldForce
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("OldForce", e));

    s << i.OldForce();
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("mass", e));

    s << ::xml_schema::as_decimal(i.mass());
  }

  // epsilon
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("epsilon", e));

    s << ::xml_schema::as_decimal(i.epsilon());
  }

  // sigma
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("sigma", e));

    s << ::xml_schema::as_decimal(i.sigma());
  }

  // type
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("type", e));

    s << i.type();
  }
}

void operator<<(::xercesc::DOMElement& e, const CDvec3Type& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // x
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("x", e));

    s << ::xml_schema::as_decimal(i.x());
  }

  // y
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("y", e));

    s << ::xml_schema::as_decimal(i.y());
  }

  // z
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("z", e));

    s << ::xml_schema::as_decimal(i.z());
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.
