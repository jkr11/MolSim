// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "input.hxx"

#include <xsd/cxx/pre.hxx>

// MetadataType
//

const MetadataType::container_type& MetadataType::container() const {
  return this->container_.get();
}

MetadataType::container_type& MetadataType::container() {
  return this->container_.get();
}

void MetadataType::container(const container_type& x) {
  this->container_.set(x);
}

void MetadataType::container(::std::auto_ptr<container_type> x) {
  this->container_.set(x);
}

const MetadataType::force_type& MetadataType::force() const {
  return this->force_.get();
}

MetadataType::force_type& MetadataType::force() { return this->force_.get(); }

void MetadataType::force(const force_type& x) { this->force_.set(x); }

void MetadataType::force(::std::auto_ptr<force_type> x) { this->force_.set(x); }

const MetadataType::delta_t_type& MetadataType::delta_t() const {
  return this->delta_t_.get();
}

MetadataType::delta_t_type& MetadataType::delta_t() {
  return this->delta_t_.get();
}

void MetadataType::delta_t(const delta_t_type& x) { this->delta_t_.set(x); }

const MetadataType::t_end_type& MetadataType::t_end() const {
  return this->t_end_.get();
}

MetadataType::t_end_type& MetadataType::t_end() { return this->t_end_.get(); }

void MetadataType::t_end(const t_end_type& x) { this->t_end_.set(x); }

const MetadataType::twoD_type& MetadataType::twoD() const {
  return this->twoD_.get();
}

MetadataType::twoD_type& MetadataType::twoD() { return this->twoD_.get(); }

void MetadataType::twoD(const twoD_type& x) { this->twoD_.set(x); }

// cuboidType
//

const cuboidType::velocity_type& cuboidType::velocity() const {
  return this->velocity_.get();
}

cuboidType::velocity_type& cuboidType::velocity() {
  return this->velocity_.get();
}

void cuboidType::velocity(const velocity_type& x) { this->velocity_.set(x); }

void cuboidType::velocity(::std::auto_ptr<velocity_type> x) {
  this->velocity_.set(x);
}

const cuboidType::corner_type& cuboidType::corner() const {
  return this->corner_.get();
}

cuboidType::corner_type& cuboidType::corner() { return this->corner_.get(); }

void cuboidType::corner(const corner_type& x) { this->corner_.set(x); }

void cuboidType::corner(::std::auto_ptr<corner_type> x) {
  this->corner_.set(x);
}

const cuboidType::dimensions_type& cuboidType::dimensions() const {
  return this->dimensions_.get();
}

cuboidType::dimensions_type& cuboidType::dimensions() {
  return this->dimensions_.get();
}

void cuboidType::dimensions(const dimensions_type& x) {
  this->dimensions_.set(x);
}

void cuboidType::dimensions(::std::auto_ptr<dimensions_type> x) {
  this->dimensions_.set(x);
}

const cuboidType::type_type& cuboidType::type() const {
  return this->type_.get();
}

cuboidType::type_type& cuboidType::type() { return this->type_.get(); }

void cuboidType::type(const type_type& x) { this->type_.set(x); }

const cuboidType::h_type& cuboidType::h() const { return this->h_.get(); }

cuboidType::h_type& cuboidType::h() { return this->h_.get(); }

void cuboidType::h(const h_type& x) { this->h_.set(x); }

const cuboidType::mass_type& cuboidType::mass() const {
  return this->mass_.get();
}

cuboidType::mass_type& cuboidType::mass() { return this->mass_.get(); }

void cuboidType::mass(const mass_type& x) { this->mass_.set(x); }

const cuboidType::epsilon_type& cuboidType::epsilon() const {
  return this->epsilon_.get();
}

cuboidType::epsilon_type& cuboidType::epsilon() { return this->epsilon_.get(); }

void cuboidType::epsilon(const epsilon_type& x) { this->epsilon_.set(x); }

const cuboidType::sigma_type& cuboidType::sigma() const {
  return this->sigma_.get();
}

cuboidType::sigma_type& cuboidType::sigma() { return this->sigma_.get(); }

void cuboidType::sigma(const sigma_type& x) { this->sigma_.set(x); }

const cuboidType::mv_type& cuboidType::mv() const { return this->mv_.get(); }

cuboidType::mv_type& cuboidType::mv() { return this->mv_.get(); }

void cuboidType::mv(const mv_type& x) { this->mv_.set(x); }

// spheroidType
//

const spheroidType::velocity_type& spheroidType::velocity() const {
  return this->velocity_.get();
}

spheroidType::velocity_type& spheroidType::velocity() {
  return this->velocity_.get();
}

void spheroidType::velocity(const velocity_type& x) { this->velocity_.set(x); }

void spheroidType::velocity(::std::auto_ptr<velocity_type> x) {
  this->velocity_.set(x);
}

const spheroidType::origin_type& spheroidType::origin() const {
  return this->origin_.get();
}

spheroidType::origin_type& spheroidType::origin() {
  return this->origin_.get();
}

void spheroidType::origin(const origin_type& x) { this->origin_.set(x); }

void spheroidType::origin(::std::auto_ptr<origin_type> x) {
  this->origin_.set(x);
}

const spheroidType::radius_type& spheroidType::radius() const {
  return this->radius_.get();
}

spheroidType::radius_type& spheroidType::radius() {
  return this->radius_.get();
}

void spheroidType::radius(const radius_type& x) { this->radius_.set(x); }

const spheroidType::type_type& spheroidType::type() const {
  return this->type_.get();
}

spheroidType::type_type& spheroidType::type() { return this->type_.get(); }

void spheroidType::type(const type_type& x) { this->type_.set(x); }

const spheroidType::h_type& spheroidType::h() const { return this->h_.get(); }

spheroidType::h_type& spheroidType::h() { return this->h_.get(); }

void spheroidType::h(const h_type& x) { this->h_.set(x); }

const spheroidType::mass_type& spheroidType::mass() const {
  return this->mass_.get();
}

spheroidType::mass_type& spheroidType::mass() { return this->mass_.get(); }

void spheroidType::mass(const mass_type& x) { this->mass_.set(x); }

const spheroidType::epsilon_type& spheroidType::epsilon() const {
  return this->epsilon_.get();
}

spheroidType::epsilon_type& spheroidType::epsilon() {
  return this->epsilon_.get();
}

void spheroidType::epsilon(const epsilon_type& x) { this->epsilon_.set(x); }

const spheroidType::sigma_type& spheroidType::sigma() const {
  return this->sigma_.get();
}

spheroidType::sigma_type& spheroidType::sigma() { return this->sigma_.get(); }

void spheroidType::sigma(const sigma_type& x) { this->sigma_.set(x); }

// Dvec3Type
//

const Dvec3Type::x_type& Dvec3Type::x() const { return this->x_.get(); }

Dvec3Type::x_type& Dvec3Type::x() { return this->x_.get(); }

void Dvec3Type::x(const x_type& x) { this->x_.set(x); }

const Dvec3Type::y_type& Dvec3Type::y() const { return this->y_.get(); }

Dvec3Type::y_type& Dvec3Type::y() { return this->y_.get(); }

void Dvec3Type::y(const y_type& x) { this->y_.set(x); }

const Dvec3Type::z_type& Dvec3Type::z() const { return this->z_.get(); }

Dvec3Type::z_type& Dvec3Type::z() { return this->z_.get(); }

void Dvec3Type::z(const z_type& x) { this->z_.set(x); }

// Ivec3Type
//

const Ivec3Type::x_type& Ivec3Type::x() const { return this->x_.get(); }

Ivec3Type::x_type& Ivec3Type::x() { return this->x_.get(); }

void Ivec3Type::x(const x_type& x) { this->x_.set(x); }

const Ivec3Type::y_type& Ivec3Type::y() const { return this->y_.get(); }

Ivec3Type::y_type& Ivec3Type::y() { return this->y_.get(); }

void Ivec3Type::y(const y_type& x) { this->y_.set(x); }

const Ivec3Type::z_type& Ivec3Type::z() const { return this->z_.get(); }

Ivec3Type::z_type& Ivec3Type::z() { return this->z_.get(); }

void Ivec3Type::z(const z_type& x) { this->z_.set(x); }

// ContainerType
//

const ContainerType::directSum_optional& ContainerType::directSum() const {
  return this->directSum_;
}

ContainerType::directSum_optional& ContainerType::directSum() {
  return this->directSum_;
}

void ContainerType::directSum(const directSum_type& x) {
  this->directSum_.set(x);
}

void ContainerType::directSum(const directSum_optional& x) {
  this->directSum_ = x;
}

void ContainerType::directSum(::std::auto_ptr<directSum_type> x) {
  this->directSum_.set(x);
}

const ContainerType::linkedCells_optional& ContainerType::linkedCells() const {
  return this->linkedCells_;
}

ContainerType::linkedCells_optional& ContainerType::linkedCells() {
  return this->linkedCells_;
}

void ContainerType::linkedCells(const linkedCells_type& x) {
  this->linkedCells_.set(x);
}

void ContainerType::linkedCells(const linkedCells_optional& x) {
  this->linkedCells_ = x;
}

void ContainerType::linkedCells(::std::auto_ptr<linkedCells_type> x) {
  this->linkedCells_.set(x);
}

// LinkedCellsType
//

const LinkedCellsType::domain_type& LinkedCellsType::domain() const {
  return this->domain_.get();
}

LinkedCellsType::domain_type& LinkedCellsType::domain() {
  return this->domain_.get();
}

void LinkedCellsType::domain(const domain_type& x) { this->domain_.set(x); }

void LinkedCellsType::domain(::std::auto_ptr<domain_type> x) {
  this->domain_.set(x);
}

const LinkedCellsType::r_cutoff_type& LinkedCellsType::r_cutoff() const {
  return this->r_cutoff_.get();
}

LinkedCellsType::r_cutoff_type& LinkedCellsType::r_cutoff() {
  return this->r_cutoff_.get();
}

void LinkedCellsType::r_cutoff(const r_cutoff_type& x) {
  this->r_cutoff_.set(x);
}

const LinkedCellsType::boundary_type& LinkedCellsType::boundary() const {
  return this->boundary_.get();
}

LinkedCellsType::boundary_type& LinkedCellsType::boundary() {
  return this->boundary_.get();
}

void LinkedCellsType::boundary(const boundary_type& x) {
  this->boundary_.set(x);
}

void LinkedCellsType::boundary(::std::auto_ptr<boundary_type> x) {
  this->boundary_.set(x);
}

// DirectSumType
//

// BoundaryType
//

const BoundaryType::Outflow_optional& BoundaryType::Outflow() const {
  return this->Outflow_;
}

BoundaryType::Outflow_optional& BoundaryType::Outflow() {
  return this->Outflow_;
}

void BoundaryType::Outflow(const Outflow_type& x) { this->Outflow_.set(x); }

void BoundaryType::Outflow(const Outflow_optional& x) { this->Outflow_ = x; }

void BoundaryType::Outflow(::std::auto_ptr<Outflow_type> x) {
  this->Outflow_.set(x);
}

const BoundaryType::Boundary_optional& BoundaryType::Boundary() const {
  return this->Boundary_;
}

BoundaryType::Boundary_optional& BoundaryType::Boundary() {
  return this->Boundary_;
}

void BoundaryType::Boundary(const Boundary_type& x) { this->Boundary_.set(x); }

void BoundaryType::Boundary(const Boundary_optional& x) { this->Boundary_ = x; }

void BoundaryType::Boundary(::std::auto_ptr<Boundary_type> x) {
  this->Boundary_.set(x);
}

// ForceType
//

const ForceType::Gravity_optional& ForceType::Gravity() const {
  return this->Gravity_;
}

ForceType::Gravity_optional& ForceType::Gravity() { return this->Gravity_; }

void ForceType::Gravity(const Gravity_type& x) { this->Gravity_.set(x); }

void ForceType::Gravity(const Gravity_optional& x) { this->Gravity_ = x; }

void ForceType::Gravity(::std::auto_ptr<Gravity_type> x) {
  this->Gravity_.set(x);
}

const ForceType::LennardJones_optional& ForceType::LennardJones() const {
  return this->LennardJones_;
}

ForceType::LennardJones_optional& ForceType::LennardJones() {
  return this->LennardJones_;
}

void ForceType::LennardJones(const LennardJones_type& x) {
  this->LennardJones_.set(x);
}

void ForceType::LennardJones(const LennardJones_optional& x) {
  this->LennardJones_ = x;
}

void ForceType::LennardJones(::std::auto_ptr<LennardJones_type> x) {
  this->LennardJones_.set(x);
}

// simulation
//

const simulation::metadata_type& simulation::metadata() const {
  return this->metadata_.get();
}

simulation::metadata_type& simulation::metadata() {
  return this->metadata_.get();
}

void simulation::metadata(const metadata_type& x) { this->metadata_.set(x); }

void simulation::metadata(::std::auto_ptr<metadata_type> x) {
  this->metadata_.set(x);
}

const simulation::cuboids_optional& simulation::cuboids() const {
  return this->cuboids_;
}

simulation::cuboids_optional& simulation::cuboids() { return this->cuboids_; }

void simulation::cuboids(const cuboids_type& x) { this->cuboids_.set(x); }

void simulation::cuboids(const cuboids_optional& x) { this->cuboids_ = x; }

void simulation::cuboids(::std::auto_ptr<cuboids_type> x) {
  this->cuboids_.set(x);
}

const simulation::spheroids_optional& simulation::spheroids() const {
  return this->spheroids_;
}

simulation::spheroids_optional& simulation::spheroids() {
  return this->spheroids_;
}

void simulation::spheroids(const spheroids_type& x) { this->spheroids_.set(x); }

void simulation::spheroids(const spheroids_optional& x) {
  this->spheroids_ = x;
}

void simulation::spheroids(::std::auto_ptr<spheroids_type> x) {
  this->spheroids_.set(x);
}

// cuboids
//

const cuboids::cuboid_sequence& cuboids::cuboid() const {
  return this->cuboid_;
}

cuboids::cuboid_sequence& cuboids::cuboid() { return this->cuboid_; }

void cuboids::cuboid(const cuboid_sequence& s) { this->cuboid_ = s; }

// spheroids
//

const spheroids::spheroid_sequence& spheroids::spheroid() const {
  return this->spheroid_;
}

spheroids::spheroid_sequence& spheroids::spheroid() { return this->spheroid_; }

void spheroids::spheroid(const spheroid_sequence& s) { this->spheroid_ = s; }

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MetadataType
//

MetadataType::MetadataType(const container_type& container,
                           const force_type& force, const delta_t_type& delta_t,
                           const t_end_type& t_end, const twoD_type& twoD)
    : ::xml_schema::type(),
      container_(container, this),
      force_(force, this),
      delta_t_(delta_t, this),
      t_end_(t_end, this),
      twoD_(twoD, this) {}

MetadataType::MetadataType(::std::auto_ptr<container_type> container,
                           ::std::auto_ptr<force_type> force,
                           const delta_t_type& delta_t, const t_end_type& t_end,
                           const twoD_type& twoD)
    : ::xml_schema::type(),
      container_(container, this),
      force_(force, this),
      delta_t_(delta_t, this),
      t_end_(t_end, this),
      twoD_(twoD, this) {}

MetadataType::MetadataType(const MetadataType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      container_(x.container_, f, this),
      force_(x.force_, f, this),
      delta_t_(x.delta_t_, f, this),
      t_end_(x.t_end_, f, this),
      twoD_(x.twoD_, f, this) {}

MetadataType::MetadataType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      container_(this),
      force_(this),
      delta_t_(this),
      t_end_(this),
      twoD_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void MetadataType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // container
    //
    if (n.name() == "container" && n.namespace_().empty()) {
      ::std::auto_ptr<container_type> r(container_traits::create(i, f, this));

      if (!container_.present()) {
        this->container_.set(r);
        continue;
      }
    }

    // force
    //
    if (n.name() == "force" && n.namespace_().empty()) {
      ::std::auto_ptr<force_type> r(force_traits::create(i, f, this));

      if (!force_.present()) {
        this->force_.set(r);
        continue;
      }
    }

    // delta_t
    //
    if (n.name() == "delta_t" && n.namespace_().empty()) {
      if (!delta_t_.present()) {
        this->delta_t_.set(delta_t_traits::create(i, f, this));
        continue;
      }
    }

    // t_end
    //
    if (n.name() == "t_end" && n.namespace_().empty()) {
      if (!t_end_.present()) {
        this->t_end_.set(t_end_traits::create(i, f, this));
        continue;
      }
    }

    // twoD
    //
    if (n.name() == "twoD" && n.namespace_().empty()) {
      if (!twoD_.present()) {
        this->twoD_.set(twoD_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!container_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("container", "");
  }

  if (!force_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("force", "");
  }

  if (!delta_t_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("delta_t", "");
  }

  if (!t_end_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("t_end", "");
  }

  if (!twoD_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("twoD", "");
  }
}

MetadataType* MetadataType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class MetadataType(*this, f, c);
}

MetadataType& MetadataType::operator=(const MetadataType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->container_ = x.container_;
    this->force_ = x.force_;
    this->delta_t_ = x.delta_t_;
    this->t_end_ = x.t_end_;
    this->twoD_ = x.twoD_;
  }

  return *this;
}

MetadataType::~MetadataType() {}

// cuboidType
//

cuboidType::cuboidType(const velocity_type& velocity, const corner_type& corner,
                       const dimensions_type& dimensions, const type_type& type,
                       const h_type& h, const mass_type& mass,
                       const epsilon_type& epsilon, const sigma_type& sigma,
                       const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      corner_(corner, this),
      dimensions_(dimensions, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

cuboidType::cuboidType(::std::auto_ptr<velocity_type> velocity,
                       ::std::auto_ptr<corner_type> corner,
                       ::std::auto_ptr<dimensions_type> dimensions,
                       const type_type& type, const h_type& h,
                       const mass_type& mass, const epsilon_type& epsilon,
                       const sigma_type& sigma, const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      corner_(corner, this),
      dimensions_(dimensions, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

cuboidType::cuboidType(const cuboidType& x, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      velocity_(x.velocity_, f, this),
      corner_(x.corner_, f, this),
      dimensions_(x.dimensions_, f, this),
      type_(x.type_, f, this),
      h_(x.h_, f, this),
      mass_(x.mass_, f, this),
      epsilon_(x.epsilon_, f, this),
      sigma_(x.sigma_, f, this),
      mv_(x.mv_, f, this) {}

cuboidType::cuboidType(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      velocity_(this),
      corner_(this),
      dimensions_(this),
      type_(this),
      h_(this),
      mass_(this),
      epsilon_(this),
      sigma_(this),
      mv_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void cuboidType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // velocity
    //
    if (n.name() == "velocity" && n.namespace_().empty()) {
      ::std::auto_ptr<velocity_type> r(velocity_traits::create(i, f, this));

      if (!velocity_.present()) {
        this->velocity_.set(r);
        continue;
      }
    }

    // corner
    //
    if (n.name() == "corner" && n.namespace_().empty()) {
      ::std::auto_ptr<corner_type> r(corner_traits::create(i, f, this));

      if (!corner_.present()) {
        this->corner_.set(r);
        continue;
      }
    }

    // dimensions
    //
    if (n.name() == "dimensions" && n.namespace_().empty()) {
      ::std::auto_ptr<dimensions_type> r(dimensions_traits::create(i, f, this));

      if (!dimensions_.present()) {
        this->dimensions_.set(r);
        continue;
      }
    }

    // type
    //
    if (n.name() == "type" && n.namespace_().empty()) {
      if (!type_.present()) {
        this->type_.set(type_traits::create(i, f, this));
        continue;
      }
    }

    // h
    //
    if (n.name() == "h" && n.namespace_().empty()) {
      if (!h_.present()) {
        this->h_.set(h_traits::create(i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name() == "mass" && n.namespace_().empty()) {
      if (!mass_.present()) {
        this->mass_.set(mass_traits::create(i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name() == "epsilon" && n.namespace_().empty()) {
      if (!epsilon_.present()) {
        this->epsilon_.set(epsilon_traits::create(i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name() == "sigma" && n.namespace_().empty()) {
      if (!sigma_.present()) {
        this->sigma_.set(sigma_traits::create(i, f, this));
        continue;
      }
    }

    // mv
    //
    if (n.name() == "mv" && n.namespace_().empty()) {
      if (!mv_.present()) {
        this->mv_.set(mv_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!velocity_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
  }

  if (!corner_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("corner", "");
  }

  if (!dimensions_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("dimensions", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("type", "");
  }

  if (!h_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("h", "");
  }

  if (!mass_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mass", "");
  }

  if (!epsilon_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("epsilon", "");
  }

  if (!sigma_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("sigma", "");
  }

  if (!mv_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mv", "");
  }
}

cuboidType* cuboidType::_clone(::xml_schema::flags f,
                               ::xml_schema::container* c) const {
  return new class cuboidType(*this, f, c);
}

cuboidType& cuboidType::operator=(const cuboidType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->velocity_ = x.velocity_;
    this->corner_ = x.corner_;
    this->dimensions_ = x.dimensions_;
    this->type_ = x.type_;
    this->h_ = x.h_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->mv_ = x.mv_;
  }

  return *this;
}

cuboidType::~cuboidType() {}

// spheroidType
//

spheroidType::spheroidType(const velocity_type& velocity,
                           const origin_type& origin, const radius_type& radius,
                           const type_type& type, const h_type& h,
                           const mass_type& mass, const epsilon_type& epsilon,
                           const sigma_type& sigma)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      origin_(origin, this),
      radius_(radius, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this) {}

spheroidType::spheroidType(::std::auto_ptr<velocity_type> velocity,
                           ::std::auto_ptr<origin_type> origin,
                           const radius_type& radius, const type_type& type,
                           const h_type& h, const mass_type& mass,
                           const epsilon_type& epsilon, const sigma_type& sigma)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      origin_(origin, this),
      radius_(radius, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this) {}

spheroidType::spheroidType(const spheroidType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      velocity_(x.velocity_, f, this),
      origin_(x.origin_, f, this),
      radius_(x.radius_, f, this),
      type_(x.type_, f, this),
      h_(x.h_, f, this),
      mass_(x.mass_, f, this),
      epsilon_(x.epsilon_, f, this),
      sigma_(x.sigma_, f, this) {}

spheroidType::spheroidType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      velocity_(this),
      origin_(this),
      radius_(this),
      type_(this),
      h_(this),
      mass_(this),
      epsilon_(this),
      sigma_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void spheroidType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // velocity
    //
    if (n.name() == "velocity" && n.namespace_().empty()) {
      ::std::auto_ptr<velocity_type> r(velocity_traits::create(i, f, this));

      if (!velocity_.present()) {
        this->velocity_.set(r);
        continue;
      }
    }

    // origin
    //
    if (n.name() == "origin" && n.namespace_().empty()) {
      ::std::auto_ptr<origin_type> r(origin_traits::create(i, f, this));

      if (!origin_.present()) {
        this->origin_.set(r);
        continue;
      }
    }

    // radius
    //
    if (n.name() == "radius" && n.namespace_().empty()) {
      if (!radius_.present()) {
        this->radius_.set(radius_traits::create(i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name() == "type" && n.namespace_().empty()) {
      if (!type_.present()) {
        this->type_.set(type_traits::create(i, f, this));
        continue;
      }
    }

    // h
    //
    if (n.name() == "h" && n.namespace_().empty()) {
      if (!h_.present()) {
        this->h_.set(h_traits::create(i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name() == "mass" && n.namespace_().empty()) {
      if (!mass_.present()) {
        this->mass_.set(mass_traits::create(i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name() == "epsilon" && n.namespace_().empty()) {
      if (!epsilon_.present()) {
        this->epsilon_.set(epsilon_traits::create(i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name() == "sigma" && n.namespace_().empty()) {
      if (!sigma_.present()) {
        this->sigma_.set(sigma_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!velocity_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
  }

  if (!origin_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("origin", "");
  }

  if (!radius_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("radius", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("type", "");
  }

  if (!h_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("h", "");
  }

  if (!mass_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mass", "");
  }

  if (!epsilon_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("epsilon", "");
  }

  if (!sigma_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("sigma", "");
  }
}

spheroidType* spheroidType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class spheroidType(*this, f, c);
}

spheroidType& spheroidType::operator=(const spheroidType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->velocity_ = x.velocity_;
    this->origin_ = x.origin_;
    this->radius_ = x.radius_;
    this->type_ = x.type_;
    this->h_ = x.h_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
  }

  return *this;
}

spheroidType::~spheroidType() {}

// Dvec3Type
//

Dvec3Type::Dvec3Type(const x_type& x, const y_type& y, const z_type& z)
    : ::xml_schema::type(), x_(x, this), y_(y, this), z_(z, this) {}

Dvec3Type::Dvec3Type(const Dvec3Type& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      x_(x.x_, f, this),
      y_(x.y_, f, this),
      z_(x.z_, f, this) {}

Dvec3Type::Dvec3Type(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      x_(this),
      y_(this),
      z_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void Dvec3Type::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // x
    //
    if (n.name() == "x" && n.namespace_().empty()) {
      if (!x_.present()) {
        this->x_.set(x_traits::create(i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name() == "y" && n.namespace_().empty()) {
      if (!y_.present()) {
        this->y_.set(y_traits::create(i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name() == "z" && n.namespace_().empty()) {
      if (!z_.present()) {
        this->z_.set(z_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x", "");
  }

  if (!y_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y", "");
  }

  if (!z_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z", "");
  }
}

Dvec3Type* Dvec3Type::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class Dvec3Type(*this, f, c);
}

Dvec3Type& Dvec3Type::operator=(const Dvec3Type& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

Dvec3Type::~Dvec3Type() {}

// Ivec3Type
//

Ivec3Type::Ivec3Type(const x_type& x, const y_type& y, const z_type& z)
    : ::xml_schema::type(), x_(x, this), y_(y, this), z_(z, this) {}

Ivec3Type::Ivec3Type(const Ivec3Type& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      x_(x.x_, f, this),
      y_(x.y_, f, this),
      z_(x.z_, f, this) {}

Ivec3Type::Ivec3Type(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      x_(this),
      y_(this),
      z_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void Ivec3Type::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // x
    //
    if (n.name() == "x" && n.namespace_().empty()) {
      if (!x_.present()) {
        this->x_.set(x_traits::create(i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name() == "y" && n.namespace_().empty()) {
      if (!y_.present()) {
        this->y_.set(y_traits::create(i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name() == "z" && n.namespace_().empty()) {
      if (!z_.present()) {
        this->z_.set(z_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x", "");
  }

  if (!y_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y", "");
  }

  if (!z_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z", "");
  }
}

Ivec3Type* Ivec3Type::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class Ivec3Type(*this, f, c);
}

Ivec3Type& Ivec3Type::operator=(const Ivec3Type& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

Ivec3Type::~Ivec3Type() {}

// ContainerType
//

ContainerType::ContainerType()
    : ::xml_schema::type(), directSum_(this), linkedCells_(this) {}

ContainerType::ContainerType(const ContainerType& x, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      directSum_(x.directSum_, f, this),
      linkedCells_(x.linkedCells_, f, this) {}

ContainerType::ContainerType(const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      directSum_(this),
      linkedCells_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ContainerType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // directSum
    //
    if (n.name() == "directSum" && n.namespace_().empty()) {
      ::std::auto_ptr<directSum_type> r(directSum_traits::create(i, f, this));

      if (!this->directSum_) {
        this->directSum_.set(r);
        continue;
      }
    }

    // linkedCells
    //
    if (n.name() == "linkedCells" && n.namespace_().empty()) {
      ::std::auto_ptr<linkedCells_type> r(
          linkedCells_traits::create(i, f, this));

      if (!this->linkedCells_) {
        this->linkedCells_.set(r);
        continue;
      }
    }

    break;
  }
}

ContainerType* ContainerType::_clone(::xml_schema::flags f,
                                     ::xml_schema::container* c) const {
  return new class ContainerType(*this, f, c);
}

ContainerType& ContainerType::operator=(const ContainerType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->directSum_ = x.directSum_;
    this->linkedCells_ = x.linkedCells_;
  }

  return *this;
}

ContainerType::~ContainerType() {}

// LinkedCellsType
//

LinkedCellsType::LinkedCellsType(const domain_type& domain,
                                 const r_cutoff_type& r_cutoff,
                                 const boundary_type& boundary)
    : ::xml_schema::type(),
      domain_(domain, this),
      r_cutoff_(r_cutoff, this),
      boundary_(boundary, this) {}

LinkedCellsType::LinkedCellsType(::std::auto_ptr<domain_type> domain,
                                 const r_cutoff_type& r_cutoff,
                                 ::std::auto_ptr<boundary_type> boundary)
    : ::xml_schema::type(),
      domain_(domain, this),
      r_cutoff_(r_cutoff, this),
      boundary_(boundary, this) {}

LinkedCellsType::LinkedCellsType(const LinkedCellsType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      domain_(x.domain_, f, this),
      r_cutoff_(x.r_cutoff_, f, this),
      boundary_(x.boundary_, f, this) {}

LinkedCellsType::LinkedCellsType(const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      domain_(this),
      r_cutoff_(this),
      boundary_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void LinkedCellsType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                            ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // domain
    //
    if (n.name() == "domain" && n.namespace_().empty()) {
      ::std::auto_ptr<domain_type> r(domain_traits::create(i, f, this));

      if (!domain_.present()) {
        this->domain_.set(r);
        continue;
      }
    }

    // r_cutoff
    //
    if (n.name() == "r_cutoff" && n.namespace_().empty()) {
      if (!r_cutoff_.present()) {
        this->r_cutoff_.set(r_cutoff_traits::create(i, f, this));
        continue;
      }
    }

    // boundary
    //
    if (n.name() == "boundary" && n.namespace_().empty()) {
      ::std::auto_ptr<boundary_type> r(boundary_traits::create(i, f, this));

      if (!boundary_.present()) {
        this->boundary_.set(r);
        continue;
      }
    }

    break;
  }

  if (!domain_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("domain", "");
  }

  if (!r_cutoff_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("r_cutoff", "");
  }

  if (!boundary_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("boundary", "");
  }
}

LinkedCellsType* LinkedCellsType::_clone(::xml_schema::flags f,
                                         ::xml_schema::container* c) const {
  return new class LinkedCellsType(*this, f, c);
}

LinkedCellsType& LinkedCellsType::operator=(const LinkedCellsType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->domain_ = x.domain_;
    this->r_cutoff_ = x.r_cutoff_;
    this->boundary_ = x.boundary_;
  }

  return *this;
}

LinkedCellsType::~LinkedCellsType() {}

// DirectSumType
//

DirectSumType::DirectSumType() : ::xml_schema::type() {}

DirectSumType::DirectSumType(const DirectSumType& x, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

DirectSumType::DirectSumType(const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

DirectSumType::DirectSumType(const ::xercesc::DOMAttr& a, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

DirectSumType::DirectSumType(const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

DirectSumType* DirectSumType::_clone(::xml_schema::flags f,
                                     ::xml_schema::container* c) const {
  return new class DirectSumType(*this, f, c);
}

DirectSumType::~DirectSumType() {}

// BoundaryType
//

BoundaryType::BoundaryType()
    : ::xml_schema::type(), Outflow_(this), Boundary_(this) {}

BoundaryType::BoundaryType(const BoundaryType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      Outflow_(x.Outflow_, f, this),
      Boundary_(x.Boundary_, f, this) {}

BoundaryType::BoundaryType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      Outflow_(this),
      Boundary_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void BoundaryType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Outflow
    //
    if (n.name() == "Outflow" && n.namespace_().empty()) {
      ::std::auto_ptr<Outflow_type> r(Outflow_traits::create(i, f, this));

      if (!this->Outflow_) {
        this->Outflow_.set(r);
        continue;
      }
    }

    // Boundary
    //
    if (n.name() == "Boundary" && n.namespace_().empty()) {
      ::std::auto_ptr<Boundary_type> r(Boundary_traits::create(i, f, this));

      if (!this->Boundary_) {
        this->Boundary_.set(r);
        continue;
      }
    }

    break;
  }
}

BoundaryType* BoundaryType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class BoundaryType(*this, f, c);
}

BoundaryType& BoundaryType::operator=(const BoundaryType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Outflow_ = x.Outflow_;
    this->Boundary_ = x.Boundary_;
  }

  return *this;
}

BoundaryType::~BoundaryType() {}

// ForceType
//

ForceType::ForceType()
    : ::xml_schema::type(), Gravity_(this), LennardJones_(this) {}

ForceType::ForceType(const ForceType& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      Gravity_(x.Gravity_, f, this),
      LennardJones_(x.LennardJones_, f, this) {}

ForceType::ForceType(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      Gravity_(this),
      LennardJones_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ForceType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Gravity
    //
    if (n.name() == "Gravity" && n.namespace_().empty()) {
      ::std::auto_ptr<Gravity_type> r(Gravity_traits::create(i, f, this));

      if (!this->Gravity_) {
        this->Gravity_.set(r);
        continue;
      }
    }

    // LennardJones
    //
    if (n.name() == "LennardJones" && n.namespace_().empty()) {
      ::std::auto_ptr<LennardJones_type> r(
          LennardJones_traits::create(i, f, this));

      if (!this->LennardJones_) {
        this->LennardJones_.set(r);
        continue;
      }
    }

    break;
  }
}

ForceType* ForceType::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class ForceType(*this, f, c);
}

ForceType& ForceType::operator=(const ForceType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Gravity_ = x.Gravity_;
    this->LennardJones_ = x.LennardJones_;
  }

  return *this;
}

ForceType::~ForceType() {}

// simulation
//

simulation::simulation(const metadata_type& metadata)
    : ::xml_schema::type(),
      metadata_(metadata, this),
      cuboids_(this),
      spheroids_(this) {}

simulation::simulation(::std::auto_ptr<metadata_type> metadata)
    : ::xml_schema::type(),
      metadata_(metadata, this),
      cuboids_(this),
      spheroids_(this) {}

simulation::simulation(const simulation& x, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      metadata_(x.metadata_, f, this),
      cuboids_(x.cuboids_, f, this),
      spheroids_(x.spheroids_, f, this) {}

simulation::simulation(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      metadata_(this),
      cuboids_(this),
      spheroids_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void simulation::parse(::xsd::cxx::xml::dom::parser<char>& p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // metadata
    //
    if (n.name() == "metadata" && n.namespace_().empty()) {
      ::std::auto_ptr<metadata_type> r(metadata_traits::create(i, f, this));

      if (!metadata_.present()) {
        this->metadata_.set(r);
        continue;
      }
    }

    // cuboids
    //
    if (n.name() == "cuboids" && n.namespace_().empty()) {
      ::std::auto_ptr<cuboids_type> r(cuboids_traits::create(i, f, this));

      if (!this->cuboids_) {
        this->cuboids_.set(r);
        continue;
      }
    }

    // spheroids
    //
    if (n.name() == "spheroids" && n.namespace_().empty()) {
      ::std::auto_ptr<spheroids_type> r(spheroids_traits::create(i, f, this));

      if (!this->spheroids_) {
        this->spheroids_.set(r);
        continue;
      }
    }

    break;
  }

  if (!metadata_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("metadata", "");
  }
}

simulation* simulation::_clone(::xml_schema::flags f,
                               ::xml_schema::container* c) const {
  return new class simulation(*this, f, c);
}

simulation& simulation::operator=(const simulation& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->metadata_ = x.metadata_;
    this->cuboids_ = x.cuboids_;
    this->spheroids_ = x.spheroids_;
  }

  return *this;
}

simulation::~simulation() {}

// cuboids
//

cuboids::cuboids() : ::xml_schema::type(), cuboid_(this) {}

cuboids::cuboids(const cuboids& x, ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), cuboid_(x.cuboid_, f, this) {}

cuboids::cuboids(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), cuboid_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void cuboids::parse(::xsd::cxx::xml::dom::parser<char>& p,
                    ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // cuboid
    //
    if (n.name() == "cuboid" && n.namespace_().empty()) {
      ::std::auto_ptr<cuboid_type> r(cuboid_traits::create(i, f, this));

      this->cuboid_.push_back(r);
      continue;
    }

    break;
  }
}

cuboids* cuboids::_clone(::xml_schema::flags f,
                         ::xml_schema::container* c) const {
  return new class cuboids(*this, f, c);
}

cuboids& cuboids::operator=(const cuboids& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->cuboid_ = x.cuboid_;
  }

  return *this;
}

cuboids::~cuboids() {}

// spheroids
//

spheroids::spheroids() : ::xml_schema::type(), spheroid_(this) {}

spheroids::spheroids(const spheroids& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), spheroid_(x.spheroid_, f, this) {}

spheroids::spheroids(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), spheroid_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void spheroids::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // spheroid
    //
    if (n.name() == "spheroid" && n.namespace_().empty()) {
      ::std::auto_ptr<spheroid_type> r(spheroid_traits::create(i, f, this));

      this->spheroid_.push_back(r);
      continue;
    }

    break;
  }
}

spheroids* spheroids::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class spheroids(*this, f, c);
}

spheroids& spheroids::operator=(const spheroids& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->spheroid_ = x.spheroid_;
  }

  return *this;
}

spheroids::~spheroids() {}

#include <istream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/sax/std-input-source.hxx>

::std::auto_ptr< ::simulation> simulation_(const ::std::string& u,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(const ::std::string& u,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(const ::std::string& u,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::simulation_(isrc, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::simulation_(isrc, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           const ::std::string& sid,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::xercesc::InputSource& i,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(::xercesc::InputSource& i,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(::xercesc::InputSource& i,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(const ::xercesc::DOMDocument& doc,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  if (f & ::xml_schema::flags::keep_dom) {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
        static_cast< ::xercesc::DOMDocument*>(doc.cloneNode(true)));

    return ::std::auto_ptr< ::simulation>(
        ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e(*doc.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "simulation" && n.namespace_() == "") {
    ::std::auto_ptr< ::simulation> r(
        ::xsd::cxx::tree::traits< ::simulation, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "simulation", "");
}

::std::auto_ptr< ::simulation> simulation_(
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d,
    ::xml_schema::flags f, const ::xml_schema::properties&) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> c(
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument*>(d->cloneNode(true))
          : 0);

  ::xercesc::DOMDocument& doc(c.get() ? *c : *d);
  const ::xercesc::DOMElement& e(*doc.getDocumentElement());

  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData(::xml_schema::dom::tree_node_key, (c.get() ? &c : &d), 0);

  if (n.name() == "simulation" && n.namespace_() == "") {
    ::std::auto_ptr< ::simulation> r(
        ::xsd::cxx::tree::traits< ::simulation, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "simulation", "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.
