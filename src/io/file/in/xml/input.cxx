// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "input.hxx"

#include <xsd/cxx/pre.hxx>

// MetadataType
//

const MetadataType::container_type& MetadataType::container() const {
  return this->container_.get();
}

MetadataType::container_type& MetadataType::container() {
  return this->container_.get();
}

void MetadataType::container(const container_type& x) {
  this->container_.set(x);
}

void MetadataType::container(::std::auto_ptr<container_type> x) {
  this->container_.set(x);
}

const MetadataType::force_type& MetadataType::force() const {
  return this->force_.get();
}

MetadataType::force_type& MetadataType::force() { return this->force_.get(); }

void MetadataType::force(const force_type& x) { this->force_.set(x); }

void MetadataType::force(::std::auto_ptr<force_type> x) { this->force_.set(x); }

const MetadataType::delta_t_type& MetadataType::delta_t() const {
  return this->delta_t_.get();
}

MetadataType::delta_t_type& MetadataType::delta_t() {
  return this->delta_t_.get();
}

void MetadataType::delta_t(const delta_t_type& x) { this->delta_t_.set(x); }

const MetadataType::t_end_type& MetadataType::t_end() const {
  return this->t_end_.get();
}

MetadataType::t_end_type& MetadataType::t_end() { return this->t_end_.get(); }

void MetadataType::t_end(const t_end_type& x) { this->t_end_.set(x); }

const MetadataType::twoD_type& MetadataType::twoD() const {
  return this->twoD_.get();
}

MetadataType::twoD_type& MetadataType::twoD() { return this->twoD_.get(); }

void MetadataType::twoD(const twoD_type& x) { this->twoD_.set(x); }

// cuboidType
//

const cuboidType::velocity_type& cuboidType::velocity() const {
  return this->velocity_.get();
}

cuboidType::velocity_type& cuboidType::velocity() {
  return this->velocity_.get();
}

void cuboidType::velocity(const velocity_type& x) { this->velocity_.set(x); }

void cuboidType::velocity(::std::auto_ptr<velocity_type> x) {
  this->velocity_.set(x);
}

const cuboidType::corner_type& cuboidType::corner() const {
  return this->corner_.get();
}

cuboidType::corner_type& cuboidType::corner() { return this->corner_.get(); }

void cuboidType::corner(const corner_type& x) { this->corner_.set(x); }

void cuboidType::corner(::std::auto_ptr<corner_type> x) {
  this->corner_.set(x);
}

const cuboidType::dimensions_type& cuboidType::dimensions() const {
  return this->dimensions_.get();
}

cuboidType::dimensions_type& cuboidType::dimensions() {
  return this->dimensions_.get();
}

void cuboidType::dimensions(const dimensions_type& x) {
  this->dimensions_.set(x);
}

void cuboidType::dimensions(::std::auto_ptr<dimensions_type> x) {
  this->dimensions_.set(x);
}

const cuboidType::type_type& cuboidType::type() const {
  return this->type_.get();
}

cuboidType::type_type& cuboidType::type() { return this->type_.get(); }

void cuboidType::type(const type_type& x) { this->type_.set(x); }

const cuboidType::h_type& cuboidType::h() const { return this->h_.get(); }

cuboidType::h_type& cuboidType::h() { return this->h_.get(); }

void cuboidType::h(const h_type& x) { this->h_.set(x); }

const cuboidType::mass_type& cuboidType::mass() const {
  return this->mass_.get();
}

cuboidType::mass_type& cuboidType::mass() { return this->mass_.get(); }

void cuboidType::mass(const mass_type& x) { this->mass_.set(x); }

const cuboidType::epsilon_type& cuboidType::epsilon() const {
  return this->epsilon_.get();
}

cuboidType::epsilon_type& cuboidType::epsilon() { return this->epsilon_.get(); }

void cuboidType::epsilon(const epsilon_type& x) { this->epsilon_.set(x); }

const cuboidType::sigma_type& cuboidType::sigma() const {
  return this->sigma_.get();
}

cuboidType::sigma_type& cuboidType::sigma() { return this->sigma_.get(); }

void cuboidType::sigma(const sigma_type& x) { this->sigma_.set(x); }

const cuboidType::mv_type& cuboidType::mv() const { return this->mv_.get(); }

cuboidType::mv_type& cuboidType::mv() { return this->mv_.get(); }

void cuboidType::mv(const mv_type& x) { this->mv_.set(x); }

// spheroidType
//

const spheroidType::velocity_type& spheroidType::velocity() const {
  return this->velocity_.get();
}

spheroidType::velocity_type& spheroidType::velocity() {
  return this->velocity_.get();
}

void spheroidType::velocity(const velocity_type& x) { this->velocity_.set(x); }

void spheroidType::velocity(::std::auto_ptr<velocity_type> x) {
  this->velocity_.set(x);
}

const spheroidType::origin_type& spheroidType::origin() const {
  return this->origin_.get();
}

spheroidType::origin_type& spheroidType::origin() {
  return this->origin_.get();
}

void spheroidType::origin(const origin_type& x) { this->origin_.set(x); }

void spheroidType::origin(::std::auto_ptr<origin_type> x) {
  this->origin_.set(x);
}

const spheroidType::radius_type& spheroidType::radius() const {
  return this->radius_.get();
}

spheroidType::radius_type& spheroidType::radius() {
  return this->radius_.get();
}

void spheroidType::radius(const radius_type& x) { this->radius_.set(x); }

const spheroidType::type_type& spheroidType::type() const {
  return this->type_.get();
}

spheroidType::type_type& spheroidType::type() { return this->type_.get(); }

void spheroidType::type(const type_type& x) { this->type_.set(x); }

const spheroidType::h_type& spheroidType::h() const { return this->h_.get(); }

spheroidType::h_type& spheroidType::h() { return this->h_.get(); }

void spheroidType::h(const h_type& x) { this->h_.set(x); }

const spheroidType::mass_type& spheroidType::mass() const {
  return this->mass_.get();
}

spheroidType::mass_type& spheroidType::mass() { return this->mass_.get(); }

void spheroidType::mass(const mass_type& x) { this->mass_.set(x); }

const spheroidType::epsilon_type& spheroidType::epsilon() const {
  return this->epsilon_.get();
}

spheroidType::epsilon_type& spheroidType::epsilon() {
  return this->epsilon_.get();
}

void spheroidType::epsilon(const epsilon_type& x) { this->epsilon_.set(x); }

const spheroidType::sigma_type& spheroidType::sigma() const {
  return this->sigma_.get();
}

spheroidType::sigma_type& spheroidType::sigma() { return this->sigma_.get(); }

void spheroidType::sigma(const sigma_type& x) { this->sigma_.set(x); }

const spheroidType::mv_type& spheroidType::mv() const {
  return this->mv_.get();
}

spheroidType::mv_type& spheroidType::mv() { return this->mv_.get(); }

void spheroidType::mv(const mv_type& x) { this->mv_.set(x); }

// ParticleSetType
//

const ParticleSetType::particle_type& ParticleSetType::particle() const {
  return this->particle_.get();
}

ParticleSetType::particle_type& ParticleSetType::particle() {
  return this->particle_.get();
}

void ParticleSetType::particle(const particle_type& x) {
  this->particle_.set(x);
}

void ParticleSetType::particle(::std::auto_ptr<particle_type> x) {
  this->particle_.set(x);
}

// ParticleType
//

const ParticleType::Position_type& ParticleType::Position() const {
  return this->Position_.get();
}

ParticleType::Position_type& ParticleType::Position() {
  return this->Position_.get();
}

void ParticleType::Position(const Position_type& x) { this->Position_.set(x); }

void ParticleType::Position(::std::auto_ptr<Position_type> x) {
  this->Position_.set(x);
}

const ParticleType::Velocity_type& ParticleType::Velocity() const {
  return this->Velocity_.get();
}

ParticleType::Velocity_type& ParticleType::Velocity() {
  return this->Velocity_.get();
}

void ParticleType::Velocity(const Velocity_type& x) { this->Velocity_.set(x); }

void ParticleType::Velocity(::std::auto_ptr<Velocity_type> x) {
  this->Velocity_.set(x);
}

const ParticleType::Force_type& ParticleType::Force() const {
  return this->Force_.get();
}

ParticleType::Force_type& ParticleType::Force() { return this->Force_.get(); }

void ParticleType::Force(const Force_type& x) { this->Force_.set(x); }

void ParticleType::Force(::std::auto_ptr<Force_type> x) { this->Force_.set(x); }

const ParticleType::OldForce_type& ParticleType::OldForce() const {
  return this->OldForce_.get();
}

ParticleType::OldForce_type& ParticleType::OldForce() {
  return this->OldForce_.get();
}

void ParticleType::OldForce(const OldForce_type& x) { this->OldForce_.set(x); }

void ParticleType::OldForce(::std::auto_ptr<OldForce_type> x) {
  this->OldForce_.set(x);
}

const ParticleType::mass_type& ParticleType::mass() const {
  return this->mass_.get();
}

ParticleType::mass_type& ParticleType::mass() { return this->mass_.get(); }

void ParticleType::mass(const mass_type& x) { this->mass_.set(x); }

const ParticleType::epsilon_type& ParticleType::epsilon() const {
  return this->epsilon_.get();
}

ParticleType::epsilon_type& ParticleType::epsilon() {
  return this->epsilon_.get();
}

void ParticleType::epsilon(const epsilon_type& x) { this->epsilon_.set(x); }

const ParticleType::sigma_type& ParticleType::sigma() const {
  return this->sigma_.get();
}

ParticleType::sigma_type& ParticleType::sigma() { return this->sigma_.get(); }

void ParticleType::sigma(const sigma_type& x) { this->sigma_.set(x); }

const ParticleType::type_type& ParticleType::type() const {
  return this->type_.get();
}

ParticleType::type_type& ParticleType::type() { return this->type_.get(); }

void ParticleType::type(const type_type& x) { this->type_.set(x); }

// Dvec3Type
//

const Dvec3Type::x_type& Dvec3Type::x() const { return this->x_.get(); }

Dvec3Type::x_type& Dvec3Type::x() { return this->x_.get(); }

void Dvec3Type::x(const x_type& x) { this->x_.set(x); }

const Dvec3Type::y_type& Dvec3Type::y() const { return this->y_.get(); }

Dvec3Type::y_type& Dvec3Type::y() { return this->y_.get(); }

void Dvec3Type::y(const y_type& x) { this->y_.set(x); }

const Dvec3Type::z_type& Dvec3Type::z() const { return this->z_.get(); }

Dvec3Type::z_type& Dvec3Type::z() { return this->z_.get(); }

void Dvec3Type::z(const z_type& x) { this->z_.set(x); }

// Ivec3Type
//

const Ivec3Type::x_type& Ivec3Type::x() const { return this->x_.get(); }

Ivec3Type::x_type& Ivec3Type::x() { return this->x_.get(); }

void Ivec3Type::x(const x_type& x) { this->x_.set(x); }

const Ivec3Type::y_type& Ivec3Type::y() const { return this->y_.get(); }

Ivec3Type::y_type& Ivec3Type::y() { return this->y_.get(); }

void Ivec3Type::y(const y_type& x) { this->y_.set(x); }

const Ivec3Type::z_type& Ivec3Type::z() const { return this->z_.get(); }

Ivec3Type::z_type& Ivec3Type::z() { return this->z_.get(); }

void Ivec3Type::z(const z_type& x) { this->z_.set(x); }

// ContainerType
//

const ContainerType::directSum_optional& ContainerType::directSum() const {
  return this->directSum_;
}

ContainerType::directSum_optional& ContainerType::directSum() {
  return this->directSum_;
}

void ContainerType::directSum(const directSum_type& x) {
  this->directSum_.set(x);
}

void ContainerType::directSum(const directSum_optional& x) {
  this->directSum_ = x;
}

void ContainerType::directSum(::std::auto_ptr<directSum_type> x) {
  this->directSum_.set(x);
}

const ContainerType::linkedCells_optional& ContainerType::linkedCells() const {
  return this->linkedCells_;
}

ContainerType::linkedCells_optional& ContainerType::linkedCells() {
  return this->linkedCells_;
}

void ContainerType::linkedCells(const linkedCells_type& x) {
  this->linkedCells_.set(x);
}

void ContainerType::linkedCells(const linkedCells_optional& x) {
  this->linkedCells_ = x;
}

void ContainerType::linkedCells(::std::auto_ptr<linkedCells_type> x) {
  this->linkedCells_.set(x);
}

// LinkedCellsType
//

const LinkedCellsType::domain_type& LinkedCellsType::domain() const {
  return this->domain_.get();
}

LinkedCellsType::domain_type& LinkedCellsType::domain() {
  return this->domain_.get();
}

void LinkedCellsType::domain(const domain_type& x) { this->domain_.set(x); }

void LinkedCellsType::domain(::std::auto_ptr<domain_type> x) {
  this->domain_.set(x);
}

const LinkedCellsType::r_cutoff_type& LinkedCellsType::r_cutoff() const {
  return this->r_cutoff_.get();
}

LinkedCellsType::r_cutoff_type& LinkedCellsType::r_cutoff() {
  return this->r_cutoff_.get();
}

void LinkedCellsType::r_cutoff(const r_cutoff_type& x) {
  this->r_cutoff_.set(x);
}

const LinkedCellsType::boundary_type& LinkedCellsType::boundary() const {
  return this->boundary_.get();
}

LinkedCellsType::boundary_type& LinkedCellsType::boundary() {
  return this->boundary_.get();
}

void LinkedCellsType::boundary(const boundary_type& x) {
  this->boundary_.set(x);
}

void LinkedCellsType::boundary(::std::auto_ptr<boundary_type> x) {
  this->boundary_.set(x);
}

// DirectSumType
//

// BoundaryType
//

const BoundaryType::Outflow_optional& BoundaryType::Outflow() const {
  return this->Outflow_;
}

BoundaryType::Outflow_optional& BoundaryType::Outflow() {
  return this->Outflow_;
}

void BoundaryType::Outflow(const Outflow_type& x) { this->Outflow_.set(x); }

void BoundaryType::Outflow(const Outflow_optional& x) { this->Outflow_ = x; }

void BoundaryType::Outflow(::std::auto_ptr<Outflow_type> x) {
  this->Outflow_.set(x);
}

const BoundaryType::Reflective_optional& BoundaryType::Reflective() const {
  return this->Reflective_;
}

BoundaryType::Reflective_optional& BoundaryType::Reflective() {
  return this->Reflective_;
}

void BoundaryType::Reflective(const Reflective_type& x) {
  this->Reflective_.set(x);
}

void BoundaryType::Reflective(const Reflective_optional& x) {
  this->Reflective_ = x;
}

void BoundaryType::Reflective(::std::auto_ptr<Reflective_type> x) {
  this->Reflective_.set(x);
}

const BoundaryType::Periodic_optional& BoundaryType::Periodic() const {
  return this->Periodic_;
}

BoundaryType::Periodic_optional& BoundaryType::Periodic() {
  return this->Periodic_;
}

void BoundaryType::Periodic(const Periodic_type& x) { this->Periodic_.set(x); }

void BoundaryType::Periodic(const Periodic_optional& x) { this->Periodic_ = x; }

void BoundaryType::Periodic(::std::auto_ptr<Periodic_type> x) {
  this->Periodic_.set(x);
}

// BoundaryConfigType
//

const BoundaryConfigType::x_high_type& BoundaryConfigType::x_high() const {
  return this->x_high_.get();
}

BoundaryConfigType::x_high_type& BoundaryConfigType::x_high() {
  return this->x_high_.get();
}

void BoundaryConfigType::x_high(const x_high_type& x) { this->x_high_.set(x); }

void BoundaryConfigType::x_high(::std::auto_ptr<x_high_type> x) {
  this->x_high_.set(x);
}

const BoundaryConfigType::x_low_type& BoundaryConfigType::x_low() const {
  return this->x_low_.get();
}

BoundaryConfigType::x_low_type& BoundaryConfigType::x_low() {
  return this->x_low_.get();
}

void BoundaryConfigType::x_low(const x_low_type& x) { this->x_low_.set(x); }

void BoundaryConfigType::x_low(::std::auto_ptr<x_low_type> x) {
  this->x_low_.set(x);
}

const BoundaryConfigType::y_high_type& BoundaryConfigType::y_high() const {
  return this->y_high_.get();
}

BoundaryConfigType::y_high_type& BoundaryConfigType::y_high() {
  return this->y_high_.get();
}

void BoundaryConfigType::y_high(const y_high_type& x) { this->y_high_.set(x); }

void BoundaryConfigType::y_high(::std::auto_ptr<y_high_type> x) {
  this->y_high_.set(x);
}

const BoundaryConfigType::y_low_type& BoundaryConfigType::y_low() const {
  return this->y_low_.get();
}

BoundaryConfigType::y_low_type& BoundaryConfigType::y_low() {
  return this->y_low_.get();
}

void BoundaryConfigType::y_low(const y_low_type& x) { this->y_low_.set(x); }

void BoundaryConfigType::y_low(::std::auto_ptr<y_low_type> x) {
  this->y_low_.set(x);
}

const BoundaryConfigType::z_high_type& BoundaryConfigType::z_high() const {
  return this->z_high_.get();
}

BoundaryConfigType::z_high_type& BoundaryConfigType::z_high() {
  return this->z_high_.get();
}

void BoundaryConfigType::z_high(const z_high_type& x) { this->z_high_.set(x); }

void BoundaryConfigType::z_high(::std::auto_ptr<z_high_type> x) {
  this->z_high_.set(x);
}

const BoundaryConfigType::z_low_type& BoundaryConfigType::z_low() const {
  return this->z_low_.get();
}

BoundaryConfigType::z_low_type& BoundaryConfigType::z_low() {
  return this->z_low_.get();
}

void BoundaryConfigType::z_low(const z_low_type& x) { this->z_low_.set(x); }

void BoundaryConfigType::z_low(::std::auto_ptr<z_low_type> x) {
  this->z_low_.set(x);
}

// ForceType
//

const ForceType::Gravity_optional& ForceType::Gravity() const {
  return this->Gravity_;
}

ForceType::Gravity_optional& ForceType::Gravity() { return this->Gravity_; }

void ForceType::Gravity(const Gravity_type& x) { this->Gravity_.set(x); }

void ForceType::Gravity(const Gravity_optional& x) { this->Gravity_ = x; }

void ForceType::Gravity(::std::auto_ptr<Gravity_type> x) {
  this->Gravity_.set(x);
}

const ForceType::LennardJones_optional& ForceType::LennardJones() const {
  return this->LennardJones_;
}

ForceType::LennardJones_optional& ForceType::LennardJones() {
  return this->LennardJones_;
}

void ForceType::LennardJones(const LennardJones_type& x) {
  this->LennardJones_.set(x);
}

void ForceType::LennardJones(const LennardJones_optional& x) {
  this->LennardJones_ = x;
}

void ForceType::LennardJones(::std::auto_ptr<LennardJones_type> x) {
  this->LennardJones_.set(x);
}

const ForceType::SingularGravity_optional& ForceType::SingularGravity() const {
  return this->SingularGravity_;
}

ForceType::SingularGravity_optional& ForceType::SingularGravity() {
  return this->SingularGravity_;
}

void ForceType::SingularGravity(const SingularGravity_type& x) {
  this->SingularGravity_.set(x);
}

void ForceType::SingularGravity(const SingularGravity_optional& x) {
  this->SingularGravity_ = x;
}

void ForceType::SingularGravity(::std::auto_ptr<SingularGravity_type> x) {
  this->SingularGravity_.set(x);
}

// GravityType
//

// LennardJonesForce
//

// SingularGravityType
//

const SingularGravityType::g_optional& SingularGravityType::g() const {
  return this->g_;
}

SingularGravityType::g_optional& SingularGravityType::g() { return this->g_; }

void SingularGravityType::g(const g_type& x) { this->g_.set(x); }

void SingularGravityType::g(const g_optional& x) { this->g_ = x; }

// ThermostatType
//

const ThermostatType::T_init_type& ThermostatType::T_init() const {
  return this->T_init_.get();
}

ThermostatType::T_init_type& ThermostatType::T_init() {
  return this->T_init_.get();
}

void ThermostatType::T_init(const T_init_type& x) { this->T_init_.set(x); }

const ThermostatType::n_thermostat_type& ThermostatType::n_thermostat() const {
  return this->n_thermostat_.get();
}

ThermostatType::n_thermostat_type& ThermostatType::n_thermostat() {
  return this->n_thermostat_.get();
}

void ThermostatType::n_thermostat(const n_thermostat_type& x) {
  this->n_thermostat_.set(x);
}

const ThermostatType::T_target_type& ThermostatType::T_target() const {
  return this->T_target_.get();
}

ThermostatType::T_target_type& ThermostatType::T_target() {
  return this->T_target_.get();
}

void ThermostatType::T_target(const T_target_type& x) {
  this->T_target_.set(x);
}

const ThermostatType::deltaT_optional& ThermostatType::deltaT() const {
  return this->deltaT_;
}

ThermostatType::deltaT_optional& ThermostatType::deltaT() {
  return this->deltaT_;
}

void ThermostatType::deltaT(const deltaT_type& x) { this->deltaT_.set(x); }

void ThermostatType::deltaT(const deltaT_optional& x) { this->deltaT_ = x; }

// simulation
//

const simulation::metadata_type& simulation::metadata() const {
  return this->metadata_.get();
}

simulation::metadata_type& simulation::metadata() {
  return this->metadata_.get();
}

void simulation::metadata(const metadata_type& x) { this->metadata_.set(x); }

void simulation::metadata(::std::auto_ptr<metadata_type> x) {
  this->metadata_.set(x);
}

const simulation::cuboids_optional& simulation::cuboids() const {
  return this->cuboids_;
}

simulation::cuboids_optional& simulation::cuboids() { return this->cuboids_; }

void simulation::cuboids(const cuboids_type& x) { this->cuboids_.set(x); }

void simulation::cuboids(const cuboids_optional& x) { this->cuboids_ = x; }

void simulation::cuboids(::std::auto_ptr<cuboids_type> x) {
  this->cuboids_.set(x);
}

const simulation::spheroids_optional& simulation::spheroids() const {
  return this->spheroids_;
}

simulation::spheroids_optional& simulation::spheroids() {
  return this->spheroids_;
}

void simulation::spheroids(const spheroids_type& x) { this->spheroids_.set(x); }

void simulation::spheroids(const spheroids_optional& x) {
  this->spheroids_ = x;
}

void simulation::spheroids(::std::auto_ptr<spheroids_type> x) {
  this->spheroids_.set(x);
}

const simulation::particles_optional& simulation::particles() const {
  return this->particles_;
}

simulation::particles_optional& simulation::particles() {
  return this->particles_;
}

void simulation::particles(const particles_type& x) { this->particles_.set(x); }

void simulation::particles(const particles_optional& x) {
  this->particles_ = x;
}

void simulation::particles(::std::auto_ptr<particles_type> x) {
  this->particles_.set(x);
}

const simulation::thermostat_optional& simulation::thermostat() const {
  return this->thermostat_;
}

simulation::thermostat_optional& simulation::thermostat() {
  return this->thermostat_;
}

void simulation::thermostat(const thermostat_type& x) {
  this->thermostat_.set(x);
}

void simulation::thermostat(const thermostat_optional& x) {
  this->thermostat_ = x;
}

void simulation::thermostat(::std::auto_ptr<thermostat_type> x) {
  this->thermostat_.set(x);
}

// cuboids
//

const cuboids::cuboid_sequence& cuboids::cuboid() const {
  return this->cuboid_;
}

cuboids::cuboid_sequence& cuboids::cuboid() { return this->cuboid_; }

void cuboids::cuboid(const cuboid_sequence& s) { this->cuboid_ = s; }

// spheroids
//

const spheroids::spheroid_sequence& spheroids::spheroid() const {
  return this->spheroid_;
}

spheroids::spheroid_sequence& spheroids::spheroid() { return this->spheroid_; }

void spheroids::spheroid(const spheroid_sequence& s) { this->spheroid_ = s; }

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MetadataType
//

MetadataType::MetadataType(const container_type& container,
                           const force_type& force, const delta_t_type& delta_t,
                           const t_end_type& t_end, const twoD_type& twoD)
    : ::xml_schema::type(),
      container_(container, this),
      force_(force, this),
      delta_t_(delta_t, this),
      t_end_(t_end, this),
      twoD_(twoD, this) {}

MetadataType::MetadataType(::std::auto_ptr<container_type> container,
                           ::std::auto_ptr<force_type> force,
                           const delta_t_type& delta_t, const t_end_type& t_end,
                           const twoD_type& twoD)
    : ::xml_schema::type(),
      container_(container, this),
      force_(force, this),
      delta_t_(delta_t, this),
      t_end_(t_end, this),
      twoD_(twoD, this) {}

MetadataType::MetadataType(const MetadataType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      container_(x.container_, f, this),
      force_(x.force_, f, this),
      delta_t_(x.delta_t_, f, this),
      t_end_(x.t_end_, f, this),
      twoD_(x.twoD_, f, this) {}

MetadataType::MetadataType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      container_(this),
      force_(this),
      delta_t_(this),
      t_end_(this),
      twoD_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void MetadataType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // container
    //
    if (n.name() == "container" && n.namespace_().empty()) {
      ::std::auto_ptr<container_type> r(container_traits::create(i, f, this));

      if (!container_.present()) {
        this->container_.set(r);
        continue;
      }
    }

    // force
    //
    if (n.name() == "force" && n.namespace_().empty()) {
      ::std::auto_ptr<force_type> r(force_traits::create(i, f, this));

      if (!force_.present()) {
        this->force_.set(r);
        continue;
      }
    }

    // delta_t
    //
    if (n.name() == "delta_t" && n.namespace_().empty()) {
      if (!delta_t_.present()) {
        this->delta_t_.set(delta_t_traits::create(i, f, this));
        continue;
      }
    }

    // t_end
    //
    if (n.name() == "t_end" && n.namespace_().empty()) {
      if (!t_end_.present()) {
        this->t_end_.set(t_end_traits::create(i, f, this));
        continue;
      }
    }

    // twoD
    //
    if (n.name() == "twoD" && n.namespace_().empty()) {
      if (!twoD_.present()) {
        this->twoD_.set(twoD_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!container_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("container", "");
  }

  if (!force_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("force", "");
  }

  if (!delta_t_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("delta_t", "");
  }

  if (!t_end_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("t_end", "");
  }

  if (!twoD_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("twoD", "");
  }
}

MetadataType* MetadataType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class MetadataType(*this, f, c);
}

MetadataType& MetadataType::operator=(const MetadataType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->container_ = x.container_;
    this->force_ = x.force_;
    this->delta_t_ = x.delta_t_;
    this->t_end_ = x.t_end_;
    this->twoD_ = x.twoD_;
  }

  return *this;
}

MetadataType::~MetadataType() {}

// cuboidType
//

cuboidType::cuboidType(const velocity_type& velocity, const corner_type& corner,
                       const dimensions_type& dimensions, const type_type& type,
                       const h_type& h, const mass_type& mass,
                       const epsilon_type& epsilon, const sigma_type& sigma,
                       const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      corner_(corner, this),
      dimensions_(dimensions, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

cuboidType::cuboidType(::std::auto_ptr<velocity_type> velocity,
                       ::std::auto_ptr<corner_type> corner,
                       ::std::auto_ptr<dimensions_type> dimensions,
                       const type_type& type, const h_type& h,
                       const mass_type& mass, const epsilon_type& epsilon,
                       const sigma_type& sigma, const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      corner_(corner, this),
      dimensions_(dimensions, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

cuboidType::cuboidType(const cuboidType& x, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      velocity_(x.velocity_, f, this),
      corner_(x.corner_, f, this),
      dimensions_(x.dimensions_, f, this),
      type_(x.type_, f, this),
      h_(x.h_, f, this),
      mass_(x.mass_, f, this),
      epsilon_(x.epsilon_, f, this),
      sigma_(x.sigma_, f, this),
      mv_(x.mv_, f, this) {}

cuboidType::cuboidType(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      velocity_(this),
      corner_(this),
      dimensions_(this),
      type_(this),
      h_(this),
      mass_(this),
      epsilon_(this),
      sigma_(this),
      mv_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void cuboidType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // velocity
    //
    if (n.name() == "velocity" && n.namespace_().empty()) {
      ::std::auto_ptr<velocity_type> r(velocity_traits::create(i, f, this));

      if (!velocity_.present()) {
        this->velocity_.set(r);
        continue;
      }
    }

    // corner
    //
    if (n.name() == "corner" && n.namespace_().empty()) {
      ::std::auto_ptr<corner_type> r(corner_traits::create(i, f, this));

      if (!corner_.present()) {
        this->corner_.set(r);
        continue;
      }
    }

    // dimensions
    //
    if (n.name() == "dimensions" && n.namespace_().empty()) {
      ::std::auto_ptr<dimensions_type> r(dimensions_traits::create(i, f, this));

      if (!dimensions_.present()) {
        this->dimensions_.set(r);
        continue;
      }
    }

    // type
    //
    if (n.name() == "type" && n.namespace_().empty()) {
      if (!type_.present()) {
        this->type_.set(type_traits::create(i, f, this));
        continue;
      }
    }

    // h
    //
    if (n.name() == "h" && n.namespace_().empty()) {
      if (!h_.present()) {
        this->h_.set(h_traits::create(i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name() == "mass" && n.namespace_().empty()) {
      if (!mass_.present()) {
        this->mass_.set(mass_traits::create(i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name() == "epsilon" && n.namespace_().empty()) {
      if (!epsilon_.present()) {
        this->epsilon_.set(epsilon_traits::create(i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name() == "sigma" && n.namespace_().empty()) {
      if (!sigma_.present()) {
        this->sigma_.set(sigma_traits::create(i, f, this));
        continue;
      }
    }

    // mv
    //
    if (n.name() == "mv" && n.namespace_().empty()) {
      if (!mv_.present()) {
        this->mv_.set(mv_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!velocity_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
  }

  if (!corner_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("corner", "");
  }

  if (!dimensions_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("dimensions", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("type", "");
  }

  if (!h_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("h", "");
  }

  if (!mass_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mass", "");
  }

  if (!epsilon_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("epsilon", "");
  }

  if (!sigma_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("sigma", "");
  }

  if (!mv_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mv", "");
  }
}

cuboidType* cuboidType::_clone(::xml_schema::flags f,
                               ::xml_schema::container* c) const {
  return new class cuboidType(*this, f, c);
}

cuboidType& cuboidType::operator=(const cuboidType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->velocity_ = x.velocity_;
    this->corner_ = x.corner_;
    this->dimensions_ = x.dimensions_;
    this->type_ = x.type_;
    this->h_ = x.h_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->mv_ = x.mv_;
  }

  return *this;
}

cuboidType::~cuboidType() {}

// spheroidType
//

spheroidType::spheroidType(const velocity_type& velocity,
                           const origin_type& origin, const radius_type& radius,
                           const type_type& type, const h_type& h,
                           const mass_type& mass, const epsilon_type& epsilon,
                           const sigma_type& sigma, const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      origin_(origin, this),
      radius_(radius, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

spheroidType::spheroidType(::std::auto_ptr<velocity_type> velocity,
                           ::std::auto_ptr<origin_type> origin,
                           const radius_type& radius, const type_type& type,
                           const h_type& h, const mass_type& mass,
                           const epsilon_type& epsilon, const sigma_type& sigma,
                           const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      origin_(origin, this),
      radius_(radius, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

spheroidType::spheroidType(const spheroidType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      velocity_(x.velocity_, f, this),
      origin_(x.origin_, f, this),
      radius_(x.radius_, f, this),
      type_(x.type_, f, this),
      h_(x.h_, f, this),
      mass_(x.mass_, f, this),
      epsilon_(x.epsilon_, f, this),
      sigma_(x.sigma_, f, this),
      mv_(x.mv_, f, this) {}

spheroidType::spheroidType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      velocity_(this),
      origin_(this),
      radius_(this),
      type_(this),
      h_(this),
      mass_(this),
      epsilon_(this),
      sigma_(this),
      mv_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void spheroidType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // velocity
    //
    if (n.name() == "velocity" && n.namespace_().empty()) {
      ::std::auto_ptr<velocity_type> r(velocity_traits::create(i, f, this));

      if (!velocity_.present()) {
        this->velocity_.set(r);
        continue;
      }
    }

    // origin
    //
    if (n.name() == "origin" && n.namespace_().empty()) {
      ::std::auto_ptr<origin_type> r(origin_traits::create(i, f, this));

      if (!origin_.present()) {
        this->origin_.set(r);
        continue;
      }
    }

    // radius
    //
    if (n.name() == "radius" && n.namespace_().empty()) {
      if (!radius_.present()) {
        this->radius_.set(radius_traits::create(i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name() == "type" && n.namespace_().empty()) {
      if (!type_.present()) {
        this->type_.set(type_traits::create(i, f, this));
        continue;
      }
    }

    // h
    //
    if (n.name() == "h" && n.namespace_().empty()) {
      if (!h_.present()) {
        this->h_.set(h_traits::create(i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name() == "mass" && n.namespace_().empty()) {
      if (!mass_.present()) {
        this->mass_.set(mass_traits::create(i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name() == "epsilon" && n.namespace_().empty()) {
      if (!epsilon_.present()) {
        this->epsilon_.set(epsilon_traits::create(i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name() == "sigma" && n.namespace_().empty()) {
      if (!sigma_.present()) {
        this->sigma_.set(sigma_traits::create(i, f, this));
        continue;
      }
    }

    // mv
    //
    if (n.name() == "mv" && n.namespace_().empty()) {
      if (!mv_.present()) {
        this->mv_.set(mv_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!velocity_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
  }

  if (!origin_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("origin", "");
  }

  if (!radius_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("radius", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("type", "");
  }

  if (!h_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("h", "");
  }

  if (!mass_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mass", "");
  }

  if (!epsilon_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("epsilon", "");
  }

  if (!sigma_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("sigma", "");
  }

  if (!mv_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mv", "");
  }
}

spheroidType* spheroidType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class spheroidType(*this, f, c);
}

spheroidType& spheroidType::operator=(const spheroidType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->velocity_ = x.velocity_;
    this->origin_ = x.origin_;
    this->radius_ = x.radius_;
    this->type_ = x.type_;
    this->h_ = x.h_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->mv_ = x.mv_;
  }

  return *this;
}

spheroidType::~spheroidType() {}

// ParticleSetType
//

ParticleSetType::ParticleSetType(const particle_type& particle)
    : ::xml_schema::type(), particle_(particle, this) {}

ParticleSetType::ParticleSetType(::std::auto_ptr<particle_type> particle)
    : ::xml_schema::type(), particle_(particle, this) {}

ParticleSetType::ParticleSetType(const ParticleSetType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), particle_(x.particle_, f, this) {}

ParticleSetType::ParticleSetType(const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), particle_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ParticleSetType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                            ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // particle
    //
    if (n.name() == "particle" && n.namespace_().empty()) {
      ::std::auto_ptr<particle_type> r(particle_traits::create(i, f, this));

      if (!particle_.present()) {
        this->particle_.set(r);
        continue;
      }
    }

    break;
  }

  if (!particle_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("particle", "");
  }
}

ParticleSetType* ParticleSetType::_clone(::xml_schema::flags f,
                                         ::xml_schema::container* c) const {
  return new class ParticleSetType(*this, f, c);
}

ParticleSetType& ParticleSetType::operator=(const ParticleSetType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->particle_ = x.particle_;
  }

  return *this;
}

ParticleSetType::~ParticleSetType() {}

// ParticleType
//

ParticleType::ParticleType(const Position_type& Position,
                           const Velocity_type& Velocity,
                           const Force_type& Force,
                           const OldForce_type& OldForce, const mass_type& mass,
                           const epsilon_type& epsilon, const sigma_type& sigma,
                           const type_type& type)
    : ::xml_schema::type(),
      Position_(Position, this),
      Velocity_(Velocity, this),
      Force_(Force, this),
      OldForce_(OldForce, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      type_(type, this) {}

ParticleType::ParticleType(::std::auto_ptr<Position_type> Position,
                           ::std::auto_ptr<Velocity_type> Velocity,
                           ::std::auto_ptr<Force_type> Force,
                           ::std::auto_ptr<OldForce_type> OldForce,
                           const mass_type& mass, const epsilon_type& epsilon,
                           const sigma_type& sigma, const type_type& type)
    : ::xml_schema::type(),
      Position_(Position, this),
      Velocity_(Velocity, this),
      Force_(Force, this),
      OldForce_(OldForce, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      type_(type, this) {}

ParticleType::ParticleType(const ParticleType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      Position_(x.Position_, f, this),
      Velocity_(x.Velocity_, f, this),
      Force_(x.Force_, f, this),
      OldForce_(x.OldForce_, f, this),
      mass_(x.mass_, f, this),
      epsilon_(x.epsilon_, f, this),
      sigma_(x.sigma_, f, this),
      type_(x.type_, f, this) {}

ParticleType::ParticleType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      Position_(this),
      Velocity_(this),
      Force_(this),
      OldForce_(this),
      mass_(this),
      epsilon_(this),
      sigma_(this),
      type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ParticleType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Position
    //
    if (n.name() == "Position" && n.namespace_().empty()) {
      ::std::auto_ptr<Position_type> r(Position_traits::create(i, f, this));

      if (!Position_.present()) {
        this->Position_.set(r);
        continue;
      }
    }

    // Velocity
    //
    if (n.name() == "Velocity" && n.namespace_().empty()) {
      ::std::auto_ptr<Velocity_type> r(Velocity_traits::create(i, f, this));

      if (!Velocity_.present()) {
        this->Velocity_.set(r);
        continue;
      }
    }

    // Force
    //
    if (n.name() == "Force" && n.namespace_().empty()) {
      ::std::auto_ptr<Force_type> r(Force_traits::create(i, f, this));

      if (!Force_.present()) {
        this->Force_.set(r);
        continue;
      }
    }

    // OldForce
    //
    if (n.name() == "OldForce" && n.namespace_().empty()) {
      ::std::auto_ptr<OldForce_type> r(OldForce_traits::create(i, f, this));

      if (!OldForce_.present()) {
        this->OldForce_.set(r);
        continue;
      }
    }

    // mass
    //
    if (n.name() == "mass" && n.namespace_().empty()) {
      if (!mass_.present()) {
        this->mass_.set(mass_traits::create(i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name() == "epsilon" && n.namespace_().empty()) {
      if (!epsilon_.present()) {
        this->epsilon_.set(epsilon_traits::create(i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name() == "sigma" && n.namespace_().empty()) {
      if (!sigma_.present()) {
        this->sigma_.set(sigma_traits::create(i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name() == "type" && n.namespace_().empty()) {
      if (!type_.present()) {
        this->type_.set(type_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Position_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("Position", "");
  }

  if (!Velocity_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("Velocity", "");
  }

  if (!Force_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("Force", "");
  }

  if (!OldForce_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("OldForce", "");
  }

  if (!mass_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mass", "");
  }

  if (!epsilon_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("epsilon", "");
  }

  if (!sigma_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("sigma", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("type", "");
  }
}

ParticleType* ParticleType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class ParticleType(*this, f, c);
}

ParticleType& ParticleType::operator=(const ParticleType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Position_ = x.Position_;
    this->Velocity_ = x.Velocity_;
    this->Force_ = x.Force_;
    this->OldForce_ = x.OldForce_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->type_ = x.type_;
  }

  return *this;
}

ParticleType::~ParticleType() {}

// Dvec3Type
//

Dvec3Type::Dvec3Type(const x_type& x, const y_type& y, const z_type& z)
    : ::xml_schema::type(), x_(x, this), y_(y, this), z_(z, this) {}

Dvec3Type::Dvec3Type(const Dvec3Type& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      x_(x.x_, f, this),
      y_(x.y_, f, this),
      z_(x.z_, f, this) {}

Dvec3Type::Dvec3Type(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      x_(this),
      y_(this),
      z_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void Dvec3Type::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // x
    //
    if (n.name() == "x" && n.namespace_().empty()) {
      if (!x_.present()) {
        this->x_.set(x_traits::create(i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name() == "y" && n.namespace_().empty()) {
      if (!y_.present()) {
        this->y_.set(y_traits::create(i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name() == "z" && n.namespace_().empty()) {
      if (!z_.present()) {
        this->z_.set(z_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x", "");
  }

  if (!y_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y", "");
  }

  if (!z_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z", "");
  }
}

Dvec3Type* Dvec3Type::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class Dvec3Type(*this, f, c);
}

Dvec3Type& Dvec3Type::operator=(const Dvec3Type& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

Dvec3Type::~Dvec3Type() {}

// Ivec3Type
//

Ivec3Type::Ivec3Type(const x_type& x, const y_type& y, const z_type& z)
    : ::xml_schema::type(), x_(x, this), y_(y, this), z_(z, this) {}

Ivec3Type::Ivec3Type(const Ivec3Type& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      x_(x.x_, f, this),
      y_(x.y_, f, this),
      z_(x.z_, f, this) {}

Ivec3Type::Ivec3Type(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      x_(this),
      y_(this),
      z_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void Ivec3Type::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // x
    //
    if (n.name() == "x" && n.namespace_().empty()) {
      if (!x_.present()) {
        this->x_.set(x_traits::create(i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name() == "y" && n.namespace_().empty()) {
      if (!y_.present()) {
        this->y_.set(y_traits::create(i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name() == "z" && n.namespace_().empty()) {
      if (!z_.present()) {
        this->z_.set(z_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x", "");
  }

  if (!y_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y", "");
  }

  if (!z_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z", "");
  }
}

Ivec3Type* Ivec3Type::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class Ivec3Type(*this, f, c);
}

Ivec3Type& Ivec3Type::operator=(const Ivec3Type& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

Ivec3Type::~Ivec3Type() {}

// ContainerType
//

ContainerType::ContainerType()
    : ::xml_schema::type(), directSum_(this), linkedCells_(this) {}

ContainerType::ContainerType(const ContainerType& x, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      directSum_(x.directSum_, f, this),
      linkedCells_(x.linkedCells_, f, this) {}

ContainerType::ContainerType(const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      directSum_(this),
      linkedCells_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ContainerType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // directSum
    //
    if (n.name() == "directSum" && n.namespace_().empty()) {
      ::std::auto_ptr<directSum_type> r(directSum_traits::create(i, f, this));

      if (!this->directSum_) {
        this->directSum_.set(r);
        continue;
      }
    }

    // linkedCells
    //
    if (n.name() == "linkedCells" && n.namespace_().empty()) {
      ::std::auto_ptr<linkedCells_type> r(
          linkedCells_traits::create(i, f, this));

      if (!this->linkedCells_) {
        this->linkedCells_.set(r);
        continue;
      }
    }

    break;
  }
}

ContainerType* ContainerType::_clone(::xml_schema::flags f,
                                     ::xml_schema::container* c) const {
  return new class ContainerType(*this, f, c);
}

ContainerType& ContainerType::operator=(const ContainerType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->directSum_ = x.directSum_;
    this->linkedCells_ = x.linkedCells_;
  }

  return *this;
}

ContainerType::~ContainerType() {}

// LinkedCellsType
//

LinkedCellsType::LinkedCellsType(const domain_type& domain,
                                 const r_cutoff_type& r_cutoff,
                                 const boundary_type& boundary)
    : ::xml_schema::type(),
      domain_(domain, this),
      r_cutoff_(r_cutoff, this),
      boundary_(boundary, this) {}

LinkedCellsType::LinkedCellsType(::std::auto_ptr<domain_type> domain,
                                 const r_cutoff_type& r_cutoff,
                                 ::std::auto_ptr<boundary_type> boundary)
    : ::xml_schema::type(),
      domain_(domain, this),
      r_cutoff_(r_cutoff, this),
      boundary_(boundary, this) {}

LinkedCellsType::LinkedCellsType(const LinkedCellsType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      domain_(x.domain_, f, this),
      r_cutoff_(x.r_cutoff_, f, this),
      boundary_(x.boundary_, f, this) {}

LinkedCellsType::LinkedCellsType(const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      domain_(this),
      r_cutoff_(this),
      boundary_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void LinkedCellsType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                            ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // domain
    //
    if (n.name() == "domain" && n.namespace_().empty()) {
      ::std::auto_ptr<domain_type> r(domain_traits::create(i, f, this));

      if (!domain_.present()) {
        this->domain_.set(r);
        continue;
      }
    }

    // r_cutoff
    //
    if (n.name() == "r_cutoff" && n.namespace_().empty()) {
      if (!r_cutoff_.present()) {
        this->r_cutoff_.set(r_cutoff_traits::create(i, f, this));
        continue;
      }
    }

    // boundary
    //
    if (n.name() == "boundary" && n.namespace_().empty()) {
      ::std::auto_ptr<boundary_type> r(boundary_traits::create(i, f, this));

      if (!boundary_.present()) {
        this->boundary_.set(r);
        continue;
      }
    }

    break;
  }

  if (!domain_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("domain", "");
  }

  if (!r_cutoff_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("r_cutoff", "");
  }

  if (!boundary_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("boundary", "");
  }
}

LinkedCellsType* LinkedCellsType::_clone(::xml_schema::flags f,
                                         ::xml_schema::container* c) const {
  return new class LinkedCellsType(*this, f, c);
}

LinkedCellsType& LinkedCellsType::operator=(const LinkedCellsType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->domain_ = x.domain_;
    this->r_cutoff_ = x.r_cutoff_;
    this->boundary_ = x.boundary_;
  }

  return *this;
}

LinkedCellsType::~LinkedCellsType() {}

// DirectSumType
//

DirectSumType::DirectSumType() : ::xml_schema::type() {}

DirectSumType::DirectSumType(const DirectSumType& x, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

DirectSumType::DirectSumType(const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

DirectSumType::DirectSumType(const ::xercesc::DOMAttr& a, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

DirectSumType::DirectSumType(const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

DirectSumType* DirectSumType::_clone(::xml_schema::flags f,
                                     ::xml_schema::container* c) const {
  return new class DirectSumType(*this, f, c);
}

DirectSumType::~DirectSumType() {}

// BoundaryType
//

BoundaryType::BoundaryType()
    : ::xml_schema::type(),
      Outflow_(this),
      Reflective_(this),
      Periodic_(this) {}

BoundaryType::BoundaryType(const BoundaryType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      Outflow_(x.Outflow_, f, this),
      Reflective_(x.Reflective_, f, this),
      Periodic_(x.Periodic_, f, this) {}

BoundaryType::BoundaryType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      Outflow_(this),
      Reflective_(this),
      Periodic_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void BoundaryType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Outflow
    //
    if (n.name() == "Outflow" && n.namespace_().empty()) {
      ::std::auto_ptr<Outflow_type> r(Outflow_traits::create(i, f, this));

      if (!this->Outflow_) {
        this->Outflow_.set(r);
        continue;
      }
    }

    // Reflective
    //
    if (n.name() == "Reflective" && n.namespace_().empty()) {
      ::std::auto_ptr<Reflective_type> r(Reflective_traits::create(i, f, this));

      if (!this->Reflective_) {
        this->Reflective_.set(r);
        continue;
      }
    }

    // Periodic
    //
    if (n.name() == "Periodic" && n.namespace_().empty()) {
      ::std::auto_ptr<Periodic_type> r(Periodic_traits::create(i, f, this));

      if (!this->Periodic_) {
        this->Periodic_.set(r);
        continue;
      }
    }

    break;
  }
}

BoundaryType* BoundaryType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class BoundaryType(*this, f, c);
}

BoundaryType& BoundaryType::operator=(const BoundaryType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Outflow_ = x.Outflow_;
    this->Reflective_ = x.Reflective_;
    this->Periodic_ = x.Periodic_;
  }

  return *this;
}

BoundaryType::~BoundaryType() {}

// BoundaryConfigType
//

BoundaryConfigType::BoundaryConfigType(const x_high_type& x_high,
                                       const x_low_type& x_low,
                                       const y_high_type& y_high,
                                       const y_low_type& y_low,
                                       const z_high_type& z_high,
                                       const z_low_type& z_low)
    : ::xml_schema::type(),
      x_high_(x_high, this),
      x_low_(x_low, this),
      y_high_(y_high, this),
      y_low_(y_low, this),
      z_high_(z_high, this),
      z_low_(z_low, this) {}

BoundaryConfigType::BoundaryConfigType(::std::auto_ptr<x_high_type> x_high,
                                       ::std::auto_ptr<x_low_type> x_low,
                                       ::std::auto_ptr<y_high_type> y_high,
                                       ::std::auto_ptr<y_low_type> y_low,
                                       ::std::auto_ptr<z_high_type> z_high,
                                       ::std::auto_ptr<z_low_type> z_low)
    : ::xml_schema::type(),
      x_high_(x_high, this),
      x_low_(x_low, this),
      y_high_(y_high, this),
      y_low_(y_low, this),
      z_high_(z_high, this),
      z_low_(z_low, this) {}

BoundaryConfigType::BoundaryConfigType(const BoundaryConfigType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      x_high_(x.x_high_, f, this),
      x_low_(x.x_low_, f, this),
      y_high_(x.y_high_, f, this),
      y_low_(x.y_low_, f, this),
      z_high_(x.z_high_, f, this),
      z_low_(x.z_low_, f, this) {}

BoundaryConfigType::BoundaryConfigType(const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      x_high_(this),
      x_low_(this),
      y_high_(this),
      y_low_(this),
      z_high_(this),
      z_low_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void BoundaryConfigType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                               ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // x_high
    //
    if (n.name() == "x_high" && n.namespace_().empty()) {
      ::std::auto_ptr<x_high_type> r(x_high_traits::create(i, f, this));

      if (!x_high_.present()) {
        this->x_high_.set(r);
        continue;
      }
    }

    // x_low
    //
    if (n.name() == "x_low" && n.namespace_().empty()) {
      ::std::auto_ptr<x_low_type> r(x_low_traits::create(i, f, this));

      if (!x_low_.present()) {
        this->x_low_.set(r);
        continue;
      }
    }

    // y_high
    //
    if (n.name() == "y_high" && n.namespace_().empty()) {
      ::std::auto_ptr<y_high_type> r(y_high_traits::create(i, f, this));

      if (!y_high_.present()) {
        this->y_high_.set(r);
        continue;
      }
    }

    // y_low
    //
    if (n.name() == "y_low" && n.namespace_().empty()) {
      ::std::auto_ptr<y_low_type> r(y_low_traits::create(i, f, this));

      if (!y_low_.present()) {
        this->y_low_.set(r);
        continue;
      }
    }

    // z_high
    //
    if (n.name() == "z_high" && n.namespace_().empty()) {
      ::std::auto_ptr<z_high_type> r(z_high_traits::create(i, f, this));

      if (!z_high_.present()) {
        this->z_high_.set(r);
        continue;
      }
    }

    // z_low
    //
    if (n.name() == "z_low" && n.namespace_().empty()) {
      ::std::auto_ptr<z_low_type> r(z_low_traits::create(i, f, this));

      if (!z_low_.present()) {
        this->z_low_.set(r);
        continue;
      }
    }

    break;
  }

  if (!x_high_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x_high", "");
  }

  if (!x_low_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x_low", "");
  }

  if (!y_high_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y_high", "");
  }

  if (!y_low_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y_low", "");
  }

  if (!z_high_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z_high", "");
  }

  if (!z_low_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z_low", "");
  }
}

BoundaryConfigType* BoundaryConfigType::_clone(
    ::xml_schema::flags f, ::xml_schema::container* c) const {
  return new class BoundaryConfigType(*this, f, c);
}

BoundaryConfigType& BoundaryConfigType::operator=(const BoundaryConfigType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->x_high_ = x.x_high_;
    this->x_low_ = x.x_low_;
    this->y_high_ = x.y_high_;
    this->y_low_ = x.y_low_;
    this->z_high_ = x.z_high_;
    this->z_low_ = x.z_low_;
  }

  return *this;
}

BoundaryConfigType::~BoundaryConfigType() {}

// ForceType
//

ForceType::ForceType()
    : ::xml_schema::type(),
      Gravity_(this),
      LennardJones_(this),
      SingularGravity_(this) {}

ForceType::ForceType(const ForceType& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      Gravity_(x.Gravity_, f, this),
      LennardJones_(x.LennardJones_, f, this),
      SingularGravity_(x.SingularGravity_, f, this) {}

ForceType::ForceType(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      Gravity_(this),
      LennardJones_(this),
      SingularGravity_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ForceType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Gravity
    //
    if (n.name() == "Gravity" && n.namespace_().empty()) {
      ::std::auto_ptr<Gravity_type> r(Gravity_traits::create(i, f, this));

      if (!this->Gravity_) {
        this->Gravity_.set(r);
        continue;
      }
    }

    // LennardJones
    //
    if (n.name() == "LennardJones" && n.namespace_().empty()) {
      ::std::auto_ptr<LennardJones_type> r(
          LennardJones_traits::create(i, f, this));

      if (!this->LennardJones_) {
        this->LennardJones_.set(r);
        continue;
      }
    }

    // SingularGravity
    //
    if (n.name() == "SingularGravity" && n.namespace_().empty()) {
      ::std::auto_ptr<SingularGravity_type> r(
          SingularGravity_traits::create(i, f, this));

      if (!this->SingularGravity_) {
        this->SingularGravity_.set(r);
        continue;
      }
    }

    break;
  }
}

ForceType* ForceType::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class ForceType(*this, f, c);
}

ForceType& ForceType::operator=(const ForceType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Gravity_ = x.Gravity_;
    this->LennardJones_ = x.LennardJones_;
    this->SingularGravity_ = x.SingularGravity_;
  }

  return *this;
}

ForceType::~ForceType() {}

// GravityType
//

GravityType::GravityType() : ::xml_schema::type() {}

GravityType::GravityType(const GravityType& x, ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

GravityType::GravityType(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

GravityType::GravityType(const ::xercesc::DOMAttr& a, ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

GravityType::GravityType(const ::std::string& s, const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

GravityType* GravityType::_clone(::xml_schema::flags f,
                                 ::xml_schema::container* c) const {
  return new class GravityType(*this, f, c);
}

GravityType::~GravityType() {}

// LennardJonesForce
//

LennardJonesForce::LennardJonesForce() : ::xml_schema::type() {}

LennardJonesForce::LennardJonesForce(const LennardJonesForce& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

LennardJonesForce::LennardJonesForce(const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

LennardJonesForce::LennardJonesForce(const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

LennardJonesForce::LennardJonesForce(const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

LennardJonesForce* LennardJonesForce::_clone(::xml_schema::flags f,
                                             ::xml_schema::container* c) const {
  return new class LennardJonesForce(*this, f, c);
}

LennardJonesForce::~LennardJonesForce() {}

// SingularGravityType
//

SingularGravityType::SingularGravityType() : ::xml_schema::type(), g_(this) {}

SingularGravityType::SingularGravityType(const SingularGravityType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), g_(x.g_, f, this) {}

SingularGravityType::SingularGravityType(const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), g_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void SingularGravityType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                                ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr& i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "g" && n.namespace_().empty()) {
      this->g_.set(g_traits::create(i, f, this));
      continue;
    }
  }
}

SingularGravityType* SingularGravityType::_clone(
    ::xml_schema::flags f, ::xml_schema::container* c) const {
  return new class SingularGravityType(*this, f, c);
}

SingularGravityType& SingularGravityType::operator=(
    const SingularGravityType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->g_ = x.g_;
  }

  return *this;
}

SingularGravityType::~SingularGravityType() {}

// ThermostatType
//

ThermostatType::ThermostatType(const T_init_type& T_init,
                               const n_thermostat_type& n_thermostat,
                               const T_target_type& T_target)
    : ::xml_schema::type(),
      T_init_(T_init, this),
      n_thermostat_(n_thermostat, this),
      T_target_(T_target, this),
      deltaT_(this) {}

ThermostatType::ThermostatType(const ThermostatType& x, ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      T_init_(x.T_init_, f, this),
      n_thermostat_(x.n_thermostat_, f, this),
      T_target_(x.T_target_, f, this),
      deltaT_(x.deltaT_, f, this) {}

ThermostatType::ThermostatType(const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      T_init_(this),
      n_thermostat_(this),
      T_target_(this),
      deltaT_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ThermostatType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // T_init
    //
    if (n.name() == "T_init" && n.namespace_().empty()) {
      if (!T_init_.present()) {
        this->T_init_.set(T_init_traits::create(i, f, this));
        continue;
      }
    }

    // n_thermostat
    //
    if (n.name() == "n_thermostat" && n.namespace_().empty()) {
      if (!n_thermostat_.present()) {
        this->n_thermostat_.set(n_thermostat_traits::create(i, f, this));
        continue;
      }
    }

    // T_target
    //
    if (n.name() == "T_target" && n.namespace_().empty()) {
      if (!T_target_.present()) {
        this->T_target_.set(T_target_traits::create(i, f, this));
        continue;
      }
    }

    // deltaT
    //
    if (n.name() == "deltaT" && n.namespace_().empty()) {
      if (!this->deltaT_) {
        this->deltaT_.set(deltaT_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!T_init_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("T_init", "");
  }

  if (!n_thermostat_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("n_thermostat", "");
  }

  if (!T_target_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("T_target", "");
  }
}

ThermostatType* ThermostatType::_clone(::xml_schema::flags f,
                                       ::xml_schema::container* c) const {
  return new class ThermostatType(*this, f, c);
}

ThermostatType& ThermostatType::operator=(const ThermostatType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->T_init_ = x.T_init_;
    this->n_thermostat_ = x.n_thermostat_;
    this->T_target_ = x.T_target_;
    this->deltaT_ = x.deltaT_;
  }

  return *this;
}

ThermostatType::~ThermostatType() {}

// simulation
//

simulation::simulation(const metadata_type& metadata)
    : ::xml_schema::type(),
      metadata_(metadata, this),
      cuboids_(this),
      spheroids_(this),
      particles_(this),
      thermostat_(this) {}

simulation::simulation(::std::auto_ptr<metadata_type> metadata)
    : ::xml_schema::type(),
      metadata_(metadata, this),
      cuboids_(this),
      spheroids_(this),
      particles_(this),
      thermostat_(this) {}

simulation::simulation(const simulation& x, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      metadata_(x.metadata_, f, this),
      cuboids_(x.cuboids_, f, this),
      spheroids_(x.spheroids_, f, this),
      particles_(x.particles_, f, this),
      thermostat_(x.thermostat_, f, this) {}

simulation::simulation(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      metadata_(this),
      cuboids_(this),
      spheroids_(this),
      particles_(this),
      thermostat_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void simulation::parse(::xsd::cxx::xml::dom::parser<char>& p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // metadata
    //
    if (n.name() == "metadata" && n.namespace_().empty()) {
      ::std::auto_ptr<metadata_type> r(metadata_traits::create(i, f, this));

      if (!metadata_.present()) {
        this->metadata_.set(r);
        continue;
      }
    }

    // cuboids
    //
    if (n.name() == "cuboids" && n.namespace_().empty()) {
      ::std::auto_ptr<cuboids_type> r(cuboids_traits::create(i, f, this));

      if (!this->cuboids_) {
        this->cuboids_.set(r);
        continue;
      }
    }

    // spheroids
    //
    if (n.name() == "spheroids" && n.namespace_().empty()) {
      ::std::auto_ptr<spheroids_type> r(spheroids_traits::create(i, f, this));

      if (!this->spheroids_) {
        this->spheroids_.set(r);
        continue;
      }
    }

    // particles
    //
    if (n.name() == "particles" && n.namespace_().empty()) {
      ::std::auto_ptr<particles_type> r(particles_traits::create(i, f, this));

      if (!this->particles_) {
        this->particles_.set(r);
        continue;
      }
    }

    // thermostat
    //
    if (n.name() == "thermostat" && n.namespace_().empty()) {
      ::std::auto_ptr<thermostat_type> r(thermostat_traits::create(i, f, this));

      if (!this->thermostat_) {
        this->thermostat_.set(r);
        continue;
      }
    }

    break;
  }

  if (!metadata_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("metadata", "");
  }
}

simulation* simulation::_clone(::xml_schema::flags f,
                               ::xml_schema::container* c) const {
  return new class simulation(*this, f, c);
}

simulation& simulation::operator=(const simulation& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->metadata_ = x.metadata_;
    this->cuboids_ = x.cuboids_;
    this->spheroids_ = x.spheroids_;
    this->particles_ = x.particles_;
    this->thermostat_ = x.thermostat_;
  }

  return *this;
}

simulation::~simulation() {}

// cuboids
//

cuboids::cuboids() : ::xml_schema::type(), cuboid_(this) {}

cuboids::cuboids(const cuboids& x, ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), cuboid_(x.cuboid_, f, this) {}

cuboids::cuboids(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), cuboid_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void cuboids::parse(::xsd::cxx::xml::dom::parser<char>& p,
                    ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // cuboid
    //
    if (n.name() == "cuboid" && n.namespace_().empty()) {
      ::std::auto_ptr<cuboid_type> r(cuboid_traits::create(i, f, this));

      this->cuboid_.push_back(r);
      continue;
    }

    break;
  }
}

cuboids* cuboids::_clone(::xml_schema::flags f,
                         ::xml_schema::container* c) const {
  return new class cuboids(*this, f, c);
}

cuboids& cuboids::operator=(const cuboids& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->cuboid_ = x.cuboid_;
  }

  return *this;
}

cuboids::~cuboids() {}

// spheroids
//

spheroids::spheroids() : ::xml_schema::type(), spheroid_(this) {}

spheroids::spheroids(const spheroids& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), spheroid_(x.spheroid_, f, this) {}

spheroids::spheroids(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), spheroid_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void spheroids::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // spheroid
    //
    if (n.name() == "spheroid" && n.namespace_().empty()) {
      ::std::auto_ptr<spheroid_type> r(spheroid_traits::create(i, f, this));

      this->spheroid_.push_back(r);
      continue;
    }

    break;
  }
}

spheroids* spheroids::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class spheroids(*this, f, c);
}

spheroids& spheroids::operator=(const spheroids& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->spheroid_ = x.spheroid_;
  }

  return *this;
}

spheroids::~spheroids() {}

#include <istream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/sax/std-input-source.hxx>

::std::auto_ptr< ::simulation> simulation_(const ::std::string& u,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(const ::std::string& u,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(const ::std::string& u,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::simulation_(isrc, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::simulation_(isrc, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           const ::std::string& sid,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::xercesc::InputSource& i,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(::xercesc::InputSource& i,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(::xercesc::InputSource& i,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(const ::xercesc::DOMDocument& doc,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  if (f & ::xml_schema::flags::keep_dom) {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
        static_cast< ::xercesc::DOMDocument*>(doc.cloneNode(true)));

    return ::std::auto_ptr< ::simulation>(
        ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e(*doc.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "simulation" && n.namespace_() == "") {
    ::std::auto_ptr< ::simulation> r(
        ::xsd::cxx::tree::traits< ::simulation, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "simulation", "");
}

::std::auto_ptr< ::simulation> simulation_(
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d,
    ::xml_schema::flags f, const ::xml_schema::properties&) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> c(
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument*>(d->cloneNode(true))
          : 0);

  ::xercesc::DOMDocument& doc(c.get() ? *c : *d);
  const ::xercesc::DOMElement& e(*doc.getDocumentElement());

  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData(::xml_schema::dom::tree_node_key, (c.get() ? &c : &d), 0);

  if (n.name() == "simulation" && n.namespace_() == "") {
    ::std::auto_ptr< ::simulation> r(
        ::xsd::cxx::tree::traits< ::simulation, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "simulation", "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.
