// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "input.hxx"

#include <xsd/cxx/pre.hxx>

// MetadataType
//

const MetadataType::container_type& MetadataType::container() const {
  return this->container_.get();
}

MetadataType::container_type& MetadataType::container() {
  return this->container_.get();
}

void MetadataType::container(const container_type& x) {
  this->container_.set(x);
}

void MetadataType::container(::std::auto_ptr<container_type> x) {
  this->container_.set(x);
}

const MetadataType::force_type& MetadataType::force() const {
  return this->force_.get();
}

MetadataType::force_type& MetadataType::force() { return this->force_.get(); }

void MetadataType::force(const force_type& x) { this->force_.set(x); }

void MetadataType::force(::std::auto_ptr<force_type> x) { this->force_.set(x); }

const MetadataType::delta_t_type& MetadataType::delta_t() const {
  return this->delta_t_.get();
}

MetadataType::delta_t_type& MetadataType::delta_t() {
  return this->delta_t_.get();
}

void MetadataType::delta_t(const delta_t_type& x) { this->delta_t_.set(x); }

const MetadataType::t_end_type& MetadataType::t_end() const {
  return this->t_end_.get();
}

MetadataType::t_end_type& MetadataType::t_end() { return this->t_end_.get(); }

void MetadataType::t_end(const t_end_type& x) { this->t_end_.set(x); }

const MetadataType::twoD_type& MetadataType::twoD() const {
  return this->twoD_.get();
}

MetadataType::twoD_type& MetadataType::twoD() { return this->twoD_.get(); }

void MetadataType::twoD(const twoD_type& x) { this->twoD_.set(x); }

const MetadataType::checkpoint_optional& MetadataType::checkpoint() const {
  return this->checkpoint_;
}

MetadataType::checkpoint_optional& MetadataType::checkpoint() {
  return this->checkpoint_;
}

void MetadataType::checkpoint(const checkpoint_type& x) {
  this->checkpoint_.set(x);
}

void MetadataType::checkpoint(const checkpoint_optional& x) {
  this->checkpoint_ = x;
}

void MetadataType::checkpoint(::std::auto_ptr<checkpoint_type> x) {
  this->checkpoint_.set(x);
}

// cuboidType
//

const cuboidType::velocity_type& cuboidType::velocity() const {
  return this->velocity_.get();
}

cuboidType::velocity_type& cuboidType::velocity() {
  return this->velocity_.get();
}

void cuboidType::velocity(const velocity_type& x) { this->velocity_.set(x); }

void cuboidType::velocity(::std::auto_ptr<velocity_type> x) {
  this->velocity_.set(x);
}

const cuboidType::corner_type& cuboidType::corner() const {
  return this->corner_.get();
}

cuboidType::corner_type& cuboidType::corner() { return this->corner_.get(); }

void cuboidType::corner(const corner_type& x) { this->corner_.set(x); }

void cuboidType::corner(::std::auto_ptr<corner_type> x) {
  this->corner_.set(x);
}

const cuboidType::dimensions_type& cuboidType::dimensions() const {
  return this->dimensions_.get();
}

cuboidType::dimensions_type& cuboidType::dimensions() {
  return this->dimensions_.get();
}

void cuboidType::dimensions(const dimensions_type& x) {
  this->dimensions_.set(x);
}

void cuboidType::dimensions(::std::auto_ptr<dimensions_type> x) {
  this->dimensions_.set(x);
}

const cuboidType::type_type& cuboidType::type() const {
  return this->type_.get();
}

cuboidType::type_type& cuboidType::type() { return this->type_.get(); }

void cuboidType::type(const type_type& x) { this->type_.set(x); }

const cuboidType::h_type& cuboidType::h() const { return this->h_.get(); }

cuboidType::h_type& cuboidType::h() { return this->h_.get(); }

void cuboidType::h(const h_type& x) { this->h_.set(x); }

const cuboidType::mass_type& cuboidType::mass() const {
  return this->mass_.get();
}

cuboidType::mass_type& cuboidType::mass() { return this->mass_.get(); }

void cuboidType::mass(const mass_type& x) { this->mass_.set(x); }

const cuboidType::epsilon_type& cuboidType::epsilon() const {
  return this->epsilon_.get();
}

cuboidType::epsilon_type& cuboidType::epsilon() { return this->epsilon_.get(); }

void cuboidType::epsilon(const epsilon_type& x) { this->epsilon_.set(x); }

const cuboidType::sigma_type& cuboidType::sigma() const {
  return this->sigma_.get();
}

cuboidType::sigma_type& cuboidType::sigma() { return this->sigma_.get(); }

void cuboidType::sigma(const sigma_type& x) { this->sigma_.set(x); }

const cuboidType::mv_type& cuboidType::mv() const { return this->mv_.get(); }

cuboidType::mv_type& cuboidType::mv() { return this->mv_.get(); }

void cuboidType::mv(const mv_type& x) { this->mv_.set(x); }

// spheroidType
//

const spheroidType::velocity_type& spheroidType::velocity() const {
  return this->velocity_.get();
}

spheroidType::velocity_type& spheroidType::velocity() {
  return this->velocity_.get();
}

void spheroidType::velocity(const velocity_type& x) { this->velocity_.set(x); }

void spheroidType::velocity(::std::auto_ptr<velocity_type> x) {
  this->velocity_.set(x);
}

const spheroidType::origin_type& spheroidType::origin() const {
  return this->origin_.get();
}

spheroidType::origin_type& spheroidType::origin() {
  return this->origin_.get();
}

void spheroidType::origin(const origin_type& x) { this->origin_.set(x); }

void spheroidType::origin(::std::auto_ptr<origin_type> x) {
  this->origin_.set(x);
}

const spheroidType::radius_type& spheroidType::radius() const {
  return this->radius_.get();
}

spheroidType::radius_type& spheroidType::radius() {
  return this->radius_.get();
}

void spheroidType::radius(const radius_type& x) { this->radius_.set(x); }

const spheroidType::type_type& spheroidType::type() const {
  return this->type_.get();
}

spheroidType::type_type& spheroidType::type() { return this->type_.get(); }

void spheroidType::type(const type_type& x) { this->type_.set(x); }

const spheroidType::h_type& spheroidType::h() const { return this->h_.get(); }

spheroidType::h_type& spheroidType::h() { return this->h_.get(); }

void spheroidType::h(const h_type& x) { this->h_.set(x); }

const spheroidType::mass_type& spheroidType::mass() const {
  return this->mass_.get();
}

spheroidType::mass_type& spheroidType::mass() { return this->mass_.get(); }

void spheroidType::mass(const mass_type& x) { this->mass_.set(x); }

const spheroidType::epsilon_type& spheroidType::epsilon() const {
  return this->epsilon_.get();
}

spheroidType::epsilon_type& spheroidType::epsilon() {
  return this->epsilon_.get();
}

void spheroidType::epsilon(const epsilon_type& x) { this->epsilon_.set(x); }

const spheroidType::sigma_type& spheroidType::sigma() const {
  return this->sigma_.get();
}

spheroidType::sigma_type& spheroidType::sigma() { return this->sigma_.get(); }

void spheroidType::sigma(const sigma_type& x) { this->sigma_.set(x); }

const spheroidType::mv_type& spheroidType::mv() const {
  return this->mv_.get();
}

spheroidType::mv_type& spheroidType::mv() { return this->mv_.get(); }

void spheroidType::mv(const mv_type& x) { this->mv_.set(x); }

// Dvec3Type
//

const Dvec3Type::x_type& Dvec3Type::x() const { return this->x_.get(); }

Dvec3Type::x_type& Dvec3Type::x() { return this->x_.get(); }

void Dvec3Type::x(const x_type& x) { this->x_.set(x); }

const Dvec3Type::y_type& Dvec3Type::y() const { return this->y_.get(); }

Dvec3Type::y_type& Dvec3Type::y() { return this->y_.get(); }

void Dvec3Type::y(const y_type& x) { this->y_.set(x); }

const Dvec3Type::z_type& Dvec3Type::z() const { return this->z_.get(); }

Dvec3Type::z_type& Dvec3Type::z() { return this->z_.get(); }

void Dvec3Type::z(const z_type& x) { this->z_.set(x); }

// Ivec3Type
//

const Ivec3Type::x_type& Ivec3Type::x() const { return this->x_.get(); }

Ivec3Type::x_type& Ivec3Type::x() { return this->x_.get(); }

void Ivec3Type::x(const x_type& x) { this->x_.set(x); }

const Ivec3Type::y_type& Ivec3Type::y() const { return this->y_.get(); }

Ivec3Type::y_type& Ivec3Type::y() { return this->y_.get(); }

void Ivec3Type::y(const y_type& x) { this->y_.set(x); }

const Ivec3Type::z_type& Ivec3Type::z() const { return this->z_.get(); }

Ivec3Type::z_type& Ivec3Type::z() { return this->z_.get(); }

void Ivec3Type::z(const z_type& x) { this->z_.set(x); }

// ContainerType
//

const ContainerType::directSum_optional& ContainerType::directSum() const {
  return this->directSum_;
}

ContainerType::directSum_optional& ContainerType::directSum() {
  return this->directSum_;
}

void ContainerType::directSum(const directSum_type& x) {
  this->directSum_.set(x);
}

void ContainerType::directSum(const directSum_optional& x) {
  this->directSum_ = x;
}

void ContainerType::directSum(::std::auto_ptr<directSum_type> x) {
  this->directSum_.set(x);
}

const ContainerType::linkedCells_optional& ContainerType::linkedCells() const {
  return this->linkedCells_;
}

ContainerType::linkedCells_optional& ContainerType::linkedCells() {
  return this->linkedCells_;
}

void ContainerType::linkedCells(const linkedCells_type& x) {
  this->linkedCells_.set(x);
}

void ContainerType::linkedCells(const linkedCells_optional& x) {
  this->linkedCells_ = x;
}

void ContainerType::linkedCells(::std::auto_ptr<linkedCells_type> x) {
  this->linkedCells_.set(x);
}

// LinkedCellsType
//

const LinkedCellsType::domain_type& LinkedCellsType::domain() const {
  return this->domain_.get();
}

LinkedCellsType::domain_type& LinkedCellsType::domain() {
  return this->domain_.get();
}

void LinkedCellsType::domain(const domain_type& x) { this->domain_.set(x); }

void LinkedCellsType::domain(::std::auto_ptr<domain_type> x) {
  this->domain_.set(x);
}

const LinkedCellsType::r_cutoff_type& LinkedCellsType::r_cutoff() const {
  return this->r_cutoff_.get();
}

LinkedCellsType::r_cutoff_type& LinkedCellsType::r_cutoff() {
  return this->r_cutoff_.get();
}

void LinkedCellsType::r_cutoff(const r_cutoff_type& x) {
  this->r_cutoff_.set(x);
}

const LinkedCellsType::boundary_type& LinkedCellsType::boundary() const {
  return this->boundary_.get();
}

LinkedCellsType::boundary_type& LinkedCellsType::boundary() {
  return this->boundary_.get();
}

void LinkedCellsType::boundary(const boundary_type& x) {
  this->boundary_.set(x);
}

void LinkedCellsType::boundary(::std::auto_ptr<boundary_type> x) {
  this->boundary_.set(x);
}

// DirectSumType
//

// BoundaryType
//

const BoundaryType::Outflow_optional& BoundaryType::Outflow() const {
  return this->Outflow_;
}

BoundaryType::Outflow_optional& BoundaryType::Outflow() {
  return this->Outflow_;
}

void BoundaryType::Outflow(const Outflow_type& x) { this->Outflow_.set(x); }

void BoundaryType::Outflow(const Outflow_optional& x) { this->Outflow_ = x; }

void BoundaryType::Outflow(::std::auto_ptr<Outflow_type> x) {
  this->Outflow_.set(x);
}

const BoundaryType::Reflective_optional& BoundaryType::Reflective() const {
  return this->Reflective_;
}

BoundaryType::Reflective_optional& BoundaryType::Reflective() {
  return this->Reflective_;
}

void BoundaryType::Reflective(const Reflective_type& x) {
  this->Reflective_.set(x);
}

void BoundaryType::Reflective(const Reflective_optional& x) {
  this->Reflective_ = x;
}

void BoundaryType::Reflective(::std::auto_ptr<Reflective_type> x) {
  this->Reflective_.set(x);
}

const BoundaryType::Periodic_optional& BoundaryType::Periodic() const {
  return this->Periodic_;
}

BoundaryType::Periodic_optional& BoundaryType::Periodic() {
  return this->Periodic_;
}

void BoundaryType::Periodic(const Periodic_type& x) { this->Periodic_.set(x); }

void BoundaryType::Periodic(const Periodic_optional& x) { this->Periodic_ = x; }

void BoundaryType::Periodic(::std::auto_ptr<Periodic_type> x) {
  this->Periodic_.set(x);
}

// BoundaryConfigType
//

const BoundaryConfigType::x_high_type& BoundaryConfigType::x_high() const {
  return this->x_high_.get();
}

BoundaryConfigType::x_high_type& BoundaryConfigType::x_high() {
  return this->x_high_.get();
}

void BoundaryConfigType::x_high(const x_high_type& x) { this->x_high_.set(x); }

void BoundaryConfigType::x_high(::std::auto_ptr<x_high_type> x) {
  this->x_high_.set(x);
}

const BoundaryConfigType::x_low_type& BoundaryConfigType::x_low() const {
  return this->x_low_.get();
}

BoundaryConfigType::x_low_type& BoundaryConfigType::x_low() {
  return this->x_low_.get();
}

void BoundaryConfigType::x_low(const x_low_type& x) { this->x_low_.set(x); }

void BoundaryConfigType::x_low(::std::auto_ptr<x_low_type> x) {
  this->x_low_.set(x);
}

const BoundaryConfigType::y_high_type& BoundaryConfigType::y_high() const {
  return this->y_high_.get();
}

BoundaryConfigType::y_high_type& BoundaryConfigType::y_high() {
  return this->y_high_.get();
}

void BoundaryConfigType::y_high(const y_high_type& x) { this->y_high_.set(x); }

void BoundaryConfigType::y_high(::std::auto_ptr<y_high_type> x) {
  this->y_high_.set(x);
}

const BoundaryConfigType::y_low_type& BoundaryConfigType::y_low() const {
  return this->y_low_.get();
}

BoundaryConfigType::y_low_type& BoundaryConfigType::y_low() {
  return this->y_low_.get();
}

void BoundaryConfigType::y_low(const y_low_type& x) { this->y_low_.set(x); }

void BoundaryConfigType::y_low(::std::auto_ptr<y_low_type> x) {
  this->y_low_.set(x);
}

const BoundaryConfigType::z_high_type& BoundaryConfigType::z_high() const {
  return this->z_high_.get();
}

BoundaryConfigType::z_high_type& BoundaryConfigType::z_high() {
  return this->z_high_.get();
}

void BoundaryConfigType::z_high(const z_high_type& x) { this->z_high_.set(x); }

void BoundaryConfigType::z_high(::std::auto_ptr<z_high_type> x) {
  this->z_high_.set(x);
}

const BoundaryConfigType::z_low_type& BoundaryConfigType::z_low() const {
  return this->z_low_.get();
}

BoundaryConfigType::z_low_type& BoundaryConfigType::z_low() {
  return this->z_low_.get();
}

void BoundaryConfigType::z_low(const z_low_type& x) { this->z_low_.set(x); }

void BoundaryConfigType::z_low(::std::auto_ptr<z_low_type> x) {
  this->z_low_.set(x);
}

// ForceType
//

const ForceType::Gravity_optional& ForceType::Gravity() const {
  return this->Gravity_;
}

ForceType::Gravity_optional& ForceType::Gravity() { return this->Gravity_; }

void ForceType::Gravity(const Gravity_type& x) { this->Gravity_.set(x); }

void ForceType::Gravity(const Gravity_optional& x) { this->Gravity_ = x; }

void ForceType::Gravity(::std::auto_ptr<Gravity_type> x) {
  this->Gravity_.set(x);
}

const ForceType::LennardJones_optional& ForceType::LennardJones() const {
  return this->LennardJones_;
}

ForceType::LennardJones_optional& ForceType::LennardJones() {
  return this->LennardJones_;
}

void ForceType::LennardJones(const LennardJones_type& x) {
  this->LennardJones_.set(x);
}

void ForceType::LennardJones(const LennardJones_optional& x) {
  this->LennardJones_ = x;
}

void ForceType::LennardJones(::std::auto_ptr<LennardJones_type> x) {
  this->LennardJones_.set(x);
}

const ForceType::SingularGravity_optional& ForceType::SingularGravity() const {
  return this->SingularGravity_;
}

ForceType::SingularGravity_optional& ForceType::SingularGravity() {
  return this->SingularGravity_;
}

void ForceType::SingularGravity(const SingularGravity_type& x) {
  this->SingularGravity_.set(x);
}

void ForceType::SingularGravity(const SingularGravity_optional& x) {
  this->SingularGravity_ = x;
}

void ForceType::SingularGravity(::std::auto_ptr<SingularGravity_type> x) {
  this->SingularGravity_.set(x);
}

const ForceType::HarmonicForce_optional& ForceType::HarmonicForce() const {
  return this->HarmonicForce_;
}

ForceType::HarmonicForce_optional& ForceType::HarmonicForce() {
  return this->HarmonicForce_;
}

void ForceType::HarmonicForce(const HarmonicForce_type& x) {
  this->HarmonicForce_.set(x);
}

void ForceType::HarmonicForce(const HarmonicForce_optional& x) {
  this->HarmonicForce_ = x;
}

void ForceType::HarmonicForce(::std::auto_ptr<HarmonicForce_type> x) {
  this->HarmonicForce_.set(x);
}

// GravityType
//

// LennardJonesForce
//

// SingularGravityType
//

const SingularGravityType::g_optional& SingularGravityType::g() const {
  return this->g_;
}

SingularGravityType::g_optional& SingularGravityType::g() { return this->g_; }

void SingularGravityType::g(const g_type& x) { this->g_.set(x); }

void SingularGravityType::g(const g_optional& x) { this->g_ = x; }

// HarmonicForceType
//

const HarmonicForceType::r_0_type& HarmonicForceType::r_0() const {
  return this->r_0_.get();
}

HarmonicForceType::r_0_type& HarmonicForceType::r_0() {
  return this->r_0_.get();
}

void HarmonicForceType::r_0(const r_0_type& x) { this->r_0_.set(x); }

const HarmonicForceType::k_type& HarmonicForceType::k() const {
  return this->k_.get();
}

HarmonicForceType::k_type& HarmonicForceType::k() { return this->k_.get(); }

void HarmonicForceType::k(const k_type& x) { this->k_.set(x); }

// ThermostatType
//

const ThermostatType::T_init_type& ThermostatType::T_init() const {
  return this->T_init_.get();
}

ThermostatType::T_init_type& ThermostatType::T_init() {
  return this->T_init_.get();
}

void ThermostatType::T_init(const T_init_type& x) { this->T_init_.set(x); }

const ThermostatType::n_thermostat_type& ThermostatType::n_thermostat() const {
  return this->n_thermostat_.get();
}

ThermostatType::n_thermostat_type& ThermostatType::n_thermostat() {
  return this->n_thermostat_.get();
}

void ThermostatType::n_thermostat(const n_thermostat_type& x) {
  this->n_thermostat_.set(x);
}

const ThermostatType::T_target_optional& ThermostatType::T_target() const {
  return this->T_target_;
}

ThermostatType::T_target_optional& ThermostatType::T_target() {
  return this->T_target_;
}

void ThermostatType::T_target(const T_target_type& x) {
  this->T_target_.set(x);
}

void ThermostatType::T_target(const T_target_optional& x) {
  this->T_target_ = x;
}

const ThermostatType::deltaT_optional& ThermostatType::deltaT() const {
  return this->deltaT_;
}

ThermostatType::deltaT_optional& ThermostatType::deltaT() {
  return this->deltaT_;
}

void ThermostatType::deltaT(const deltaT_type& x) { this->deltaT_.set(x); }

void ThermostatType::deltaT(const deltaT_optional& x) { this->deltaT_ = x; }

// simulation
//

const simulation::metadata_type& simulation::metadata() const {
  return this->metadata_.get();
}

simulation::metadata_type& simulation::metadata() {
  return this->metadata_.get();
}

void simulation::metadata(const metadata_type& x) { this->metadata_.set(x); }

void simulation::metadata(::std::auto_ptr<metadata_type> x) {
  this->metadata_.set(x);
}

const simulation::cuboids_optional& simulation::cuboids() const {
  return this->cuboids_;
}

simulation::cuboids_optional& simulation::cuboids() { return this->cuboids_; }

void simulation::cuboids(const cuboids_type& x) { this->cuboids_.set(x); }

void simulation::cuboids(const cuboids_optional& x) { this->cuboids_ = x; }

void simulation::cuboids(::std::auto_ptr<cuboids_type> x) {
  this->cuboids_.set(x);
}

const simulation::spheroids_optional& simulation::spheroids() const {
  return this->spheroids_;
}

simulation::spheroids_optional& simulation::spheroids() {
  return this->spheroids_;
}

void simulation::spheroids(const spheroids_type& x) { this->spheroids_.set(x); }

void simulation::spheroids(const spheroids_optional& x) {
  this->spheroids_ = x;
}

void simulation::spheroids(::std::auto_ptr<spheroids_type> x) {
  this->spheroids_.set(x);
}

const simulation::thermostat_optional& simulation::thermostat() const {
  return this->thermostat_;
}

simulation::thermostat_optional& simulation::thermostat() {
  return this->thermostat_;
}

void simulation::thermostat(const thermostat_type& x) {
  this->thermostat_.set(x);
}

void simulation::thermostat(const thermostat_optional& x) {
  this->thermostat_ = x;
}

void simulation::thermostat(::std::auto_ptr<thermostat_type> x) {
  this->thermostat_.set(x);
}

// cuboids
//

const cuboids::cuboid_sequence& cuboids::cuboid() const {
  return this->cuboid_;
}

cuboids::cuboid_sequence& cuboids::cuboid() { return this->cuboid_; }

void cuboids::cuboid(const cuboid_sequence& s) { this->cuboid_ = s; }

// spheroids
//

const spheroids::spheroid_sequence& spheroids::spheroid() const {
  return this->spheroid_;
}

spheroids::spheroid_sequence& spheroids::spheroid() { return this->spheroid_; }

void spheroids::spheroid(const spheroid_sequence& s) { this->spheroid_ = s; }

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MetadataType
//

MetadataType::MetadataType(const container_type& container,
                           const force_type& force, const delta_t_type& delta_t,
                           const t_end_type& t_end, const twoD_type& twoD)
    : ::xml_schema::type(),
      container_(container, this),
      force_(force, this),
      delta_t_(delta_t, this),
      t_end_(t_end, this),
      twoD_(twoD, this),
      checkpoint_(this) {}

MetadataType::MetadataType(::std::auto_ptr<container_type> container,
                           ::std::auto_ptr<force_type> force,
                           const delta_t_type& delta_t, const t_end_type& t_end,
                           const twoD_type& twoD)
    : ::xml_schema::type(),
      container_(container, this),
      force_(force, this),
      delta_t_(delta_t, this),
      t_end_(t_end, this),
      twoD_(twoD, this),
      checkpoint_(this) {}

MetadataType::MetadataType(const MetadataType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      container_(x.container_, f, this),
      force_(x.force_, f, this),
      delta_t_(x.delta_t_, f, this),
      t_end_(x.t_end_, f, this),
      twoD_(x.twoD_, f, this),
      checkpoint_(x.checkpoint_, f, this) {}

MetadataType::MetadataType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      container_(this),
      force_(this),
      delta_t_(this),
      t_end_(this),
      twoD_(this),
      checkpoint_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void MetadataType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // container
    //
    if (n.name() == "container" && n.namespace_().empty()) {
      ::std::auto_ptr<container_type> r(container_traits::create(i, f, this));

      if (!container_.present()) {
        this->container_.set(r);
        continue;
      }
    }

    // force
    //
    if (n.name() == "force" && n.namespace_().empty()) {
      ::std::auto_ptr<force_type> r(force_traits::create(i, f, this));

      if (!force_.present()) {
        this->force_.set(r);
        continue;
      }
    }

    // delta_t
    //
    if (n.name() == "delta_t" && n.namespace_().empty()) {
      if (!delta_t_.present()) {
        this->delta_t_.set(delta_t_traits::create(i, f, this));
        continue;
      }
    }

    // t_end
    //
    if (n.name() == "t_end" && n.namespace_().empty()) {
      if (!t_end_.present()) {
        this->t_end_.set(t_end_traits::create(i, f, this));
        continue;
      }
    }

    // twoD
    //
    if (n.name() == "twoD" && n.namespace_().empty()) {
      if (!twoD_.present()) {
        this->twoD_.set(twoD_traits::create(i, f, this));
        continue;
      }
    }

    // checkpoint
    //
    if (n.name() == "checkpoint" && n.namespace_().empty()) {
      ::std::auto_ptr<checkpoint_type> r(checkpoint_traits::create(i, f, this));

      if (!this->checkpoint_) {
        this->checkpoint_.set(r);
        continue;
      }
    }

    break;
  }

  if (!container_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("container", "");
  }

  if (!force_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("force", "");
  }

  if (!delta_t_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("delta_t", "");
  }

  if (!t_end_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("t_end", "");
  }

  if (!twoD_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("twoD", "");
  }
}

MetadataType* MetadataType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class MetadataType(*this, f, c);
}

MetadataType& MetadataType::operator=(const MetadataType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->container_ = x.container_;
    this->force_ = x.force_;
    this->delta_t_ = x.delta_t_;
    this->t_end_ = x.t_end_;
    this->twoD_ = x.twoD_;
    this->checkpoint_ = x.checkpoint_;
  }

  return *this;
}

MetadataType::~MetadataType() {}

// cuboidType
//

cuboidType::cuboidType(const velocity_type& velocity, const corner_type& corner,
                       const dimensions_type& dimensions, const type_type& type,
                       const h_type& h, const mass_type& mass,
                       const epsilon_type& epsilon, const sigma_type& sigma,
                       const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      corner_(corner, this),
      dimensions_(dimensions, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

cuboidType::cuboidType(::std::auto_ptr<velocity_type> velocity,
                       ::std::auto_ptr<corner_type> corner,
                       ::std::auto_ptr<dimensions_type> dimensions,
                       const type_type& type, const h_type& h,
                       const mass_type& mass, const epsilon_type& epsilon,
                       const sigma_type& sigma, const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      corner_(corner, this),
      dimensions_(dimensions, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

cuboidType::cuboidType(const cuboidType& x, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      velocity_(x.velocity_, f, this),
      corner_(x.corner_, f, this),
      dimensions_(x.dimensions_, f, this),
      type_(x.type_, f, this),
      h_(x.h_, f, this),
      mass_(x.mass_, f, this),
      epsilon_(x.epsilon_, f, this),
      sigma_(x.sigma_, f, this),
      mv_(x.mv_, f, this) {}

cuboidType::cuboidType(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      velocity_(this),
      corner_(this),
      dimensions_(this),
      type_(this),
      h_(this),
      mass_(this),
      epsilon_(this),
      sigma_(this),
      mv_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void cuboidType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // velocity
    //
    if (n.name() == "velocity" && n.namespace_().empty()) {
      ::std::auto_ptr<velocity_type> r(velocity_traits::create(i, f, this));

      if (!velocity_.present()) {
        this->velocity_.set(r);
        continue;
      }
    }

    // corner
    //
    if (n.name() == "corner" && n.namespace_().empty()) {
      ::std::auto_ptr<corner_type> r(corner_traits::create(i, f, this));

      if (!corner_.present()) {
        this->corner_.set(r);
        continue;
      }
    }

    // dimensions
    //
    if (n.name() == "dimensions" && n.namespace_().empty()) {
      ::std::auto_ptr<dimensions_type> r(dimensions_traits::create(i, f, this));

      if (!dimensions_.present()) {
        this->dimensions_.set(r);
        continue;
      }
    }

    // type
    //
    if (n.name() == "type" && n.namespace_().empty()) {
      if (!type_.present()) {
        this->type_.set(type_traits::create(i, f, this));
        continue;
      }
    }

    // h
    //
    if (n.name() == "h" && n.namespace_().empty()) {
      if (!h_.present()) {
        this->h_.set(h_traits::create(i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name() == "mass" && n.namespace_().empty()) {
      if (!mass_.present()) {
        this->mass_.set(mass_traits::create(i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name() == "epsilon" && n.namespace_().empty()) {
      if (!epsilon_.present()) {
        this->epsilon_.set(epsilon_traits::create(i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name() == "sigma" && n.namespace_().empty()) {
      if (!sigma_.present()) {
        this->sigma_.set(sigma_traits::create(i, f, this));
        continue;
      }
    }

    // mv
    //
    if (n.name() == "mv" && n.namespace_().empty()) {
      if (!mv_.present()) {
        this->mv_.set(mv_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!velocity_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
  }

  if (!corner_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("corner", "");
  }

  if (!dimensions_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("dimensions", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("type", "");
  }

  if (!h_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("h", "");
  }

  if (!mass_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mass", "");
  }

  if (!epsilon_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("epsilon", "");
  }

  if (!sigma_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("sigma", "");
  }

  if (!mv_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mv", "");
  }
}

cuboidType* cuboidType::_clone(::xml_schema::flags f,
                               ::xml_schema::container* c) const {
  return new class cuboidType(*this, f, c);
}

cuboidType& cuboidType::operator=(const cuboidType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->velocity_ = x.velocity_;
    this->corner_ = x.corner_;
    this->dimensions_ = x.dimensions_;
    this->type_ = x.type_;
    this->h_ = x.h_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->mv_ = x.mv_;
  }

  return *this;
}

cuboidType::~cuboidType() {}

// spheroidType
//

spheroidType::spheroidType(const velocity_type& velocity,
                           const origin_type& origin, const radius_type& radius,
                           const type_type& type, const h_type& h,
                           const mass_type& mass, const epsilon_type& epsilon,
                           const sigma_type& sigma, const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      origin_(origin, this),
      radius_(radius, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

spheroidType::spheroidType(::std::auto_ptr<velocity_type> velocity,
                           ::std::auto_ptr<origin_type> origin,
                           const radius_type& radius, const type_type& type,
                           const h_type& h, const mass_type& mass,
                           const epsilon_type& epsilon, const sigma_type& sigma,
                           const mv_type& mv)
    : ::xml_schema::type(),
      velocity_(velocity, this),
      origin_(origin, this),
      radius_(radius, this),
      type_(type, this),
      h_(h, this),
      mass_(mass, this),
      epsilon_(epsilon, this),
      sigma_(sigma, this),
      mv_(mv, this) {}

spheroidType::spheroidType(const spheroidType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      velocity_(x.velocity_, f, this),
      origin_(x.origin_, f, this),
      radius_(x.radius_, f, this),
      type_(x.type_, f, this),
      h_(x.h_, f, this),
      mass_(x.mass_, f, this),
      epsilon_(x.epsilon_, f, this),
      sigma_(x.sigma_, f, this),
      mv_(x.mv_, f, this) {}

spheroidType::spheroidType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      velocity_(this),
      origin_(this),
      radius_(this),
      type_(this),
      h_(this),
      mass_(this),
      epsilon_(this),
      sigma_(this),
      mv_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void spheroidType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // velocity
    //
    if (n.name() == "velocity" && n.namespace_().empty()) {
      ::std::auto_ptr<velocity_type> r(velocity_traits::create(i, f, this));

      if (!velocity_.present()) {
        this->velocity_.set(r);
        continue;
      }
    }

    // origin
    //
    if (n.name() == "origin" && n.namespace_().empty()) {
      ::std::auto_ptr<origin_type> r(origin_traits::create(i, f, this));

      if (!origin_.present()) {
        this->origin_.set(r);
        continue;
      }
    }

    // radius
    //
    if (n.name() == "radius" && n.namespace_().empty()) {
      if (!radius_.present()) {
        this->radius_.set(radius_traits::create(i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name() == "type" && n.namespace_().empty()) {
      if (!type_.present()) {
        this->type_.set(type_traits::create(i, f, this));
        continue;
      }
    }

    // h
    //
    if (n.name() == "h" && n.namespace_().empty()) {
      if (!h_.present()) {
        this->h_.set(h_traits::create(i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name() == "mass" && n.namespace_().empty()) {
      if (!mass_.present()) {
        this->mass_.set(mass_traits::create(i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name() == "epsilon" && n.namespace_().empty()) {
      if (!epsilon_.present()) {
        this->epsilon_.set(epsilon_traits::create(i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name() == "sigma" && n.namespace_().empty()) {
      if (!sigma_.present()) {
        this->sigma_.set(sigma_traits::create(i, f, this));
        continue;
      }
    }

    // mv
    //
    if (n.name() == "mv" && n.namespace_().empty()) {
      if (!mv_.present()) {
        this->mv_.set(mv_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!velocity_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
  }

  if (!origin_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("origin", "");
  }

  if (!radius_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("radius", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("type", "");
  }

  if (!h_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("h", "");
  }

  if (!mass_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mass", "");
  }

  if (!epsilon_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("epsilon", "");
  }

  if (!sigma_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("sigma", "");
  }

  if (!mv_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("mv", "");
  }
}

spheroidType* spheroidType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class spheroidType(*this, f, c);
}

spheroidType& spheroidType::operator=(const spheroidType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->velocity_ = x.velocity_;
    this->origin_ = x.origin_;
    this->radius_ = x.radius_;
    this->type_ = x.type_;
    this->h_ = x.h_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->mv_ = x.mv_;
  }

  return *this;
}

spheroidType::~spheroidType() {}

// Dvec3Type
//

Dvec3Type::Dvec3Type(const x_type& x, const y_type& y, const z_type& z)
    : ::xml_schema::type(), x_(x, this), y_(y, this), z_(z, this) {}

Dvec3Type::Dvec3Type(const Dvec3Type& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      x_(x.x_, f, this),
      y_(x.y_, f, this),
      z_(x.z_, f, this) {}

Dvec3Type::Dvec3Type(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      x_(this),
      y_(this),
      z_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void Dvec3Type::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // x
    //
    if (n.name() == "x" && n.namespace_().empty()) {
      if (!x_.present()) {
        this->x_.set(x_traits::create(i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name() == "y" && n.namespace_().empty()) {
      if (!y_.present()) {
        this->y_.set(y_traits::create(i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name() == "z" && n.namespace_().empty()) {
      if (!z_.present()) {
        this->z_.set(z_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x", "");
  }

  if (!y_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y", "");
  }

  if (!z_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z", "");
  }
}

Dvec3Type* Dvec3Type::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class Dvec3Type(*this, f, c);
}

Dvec3Type& Dvec3Type::operator=(const Dvec3Type& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

Dvec3Type::~Dvec3Type() {}

// Ivec3Type
//

Ivec3Type::Ivec3Type(const x_type& x, const y_type& y, const z_type& z)
    : ::xml_schema::type(), x_(x, this), y_(y, this), z_(z, this) {}

Ivec3Type::Ivec3Type(const Ivec3Type& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      x_(x.x_, f, this),
      y_(x.y_, f, this),
      z_(x.z_, f, this) {}

Ivec3Type::Ivec3Type(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      x_(this),
      y_(this),
      z_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void Ivec3Type::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // x
    //
    if (n.name() == "x" && n.namespace_().empty()) {
      if (!x_.present()) {
        this->x_.set(x_traits::create(i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name() == "y" && n.namespace_().empty()) {
      if (!y_.present()) {
        this->y_.set(y_traits::create(i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name() == "z" && n.namespace_().empty()) {
      if (!z_.present()) {
        this->z_.set(z_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x", "");
  }

  if (!y_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y", "");
  }

  if (!z_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z", "");
  }
}

Ivec3Type* Ivec3Type::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class Ivec3Type(*this, f, c);
}

Ivec3Type& Ivec3Type::operator=(const Ivec3Type& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

Ivec3Type::~Ivec3Type() {}

// ContainerType
//

ContainerType::ContainerType()
    : ::xml_schema::type(), directSum_(this), linkedCells_(this) {}

ContainerType::ContainerType(const ContainerType& x, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      directSum_(x.directSum_, f, this),
      linkedCells_(x.linkedCells_, f, this) {}

ContainerType::ContainerType(const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      directSum_(this),
      linkedCells_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ContainerType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // directSum
    //
    if (n.name() == "directSum" && n.namespace_().empty()) {
      ::std::auto_ptr<directSum_type> r(directSum_traits::create(i, f, this));

      if (!this->directSum_) {
        this->directSum_.set(r);
        continue;
      }
    }

    // linkedCells
    //
    if (n.name() == "linkedCells" && n.namespace_().empty()) {
      ::std::auto_ptr<linkedCells_type> r(
          linkedCells_traits::create(i, f, this));

      if (!this->linkedCells_) {
        this->linkedCells_.set(r);
        continue;
      }
    }

    break;
  }
}

ContainerType* ContainerType::_clone(::xml_schema::flags f,
                                     ::xml_schema::container* c) const {
  return new class ContainerType(*this, f, c);
}

ContainerType& ContainerType::operator=(const ContainerType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->directSum_ = x.directSum_;
    this->linkedCells_ = x.linkedCells_;
  }

  return *this;
}

ContainerType::~ContainerType() {}

// LinkedCellsType
//

LinkedCellsType::LinkedCellsType(const domain_type& domain,
                                 const r_cutoff_type& r_cutoff,
                                 const boundary_type& boundary)
    : ::xml_schema::type(),
      domain_(domain, this),
      r_cutoff_(r_cutoff, this),
      boundary_(boundary, this) {}

LinkedCellsType::LinkedCellsType(::std::auto_ptr<domain_type> domain,
                                 const r_cutoff_type& r_cutoff,
                                 ::std::auto_ptr<boundary_type> boundary)
    : ::xml_schema::type(),
      domain_(domain, this),
      r_cutoff_(r_cutoff, this),
      boundary_(boundary, this) {}

LinkedCellsType::LinkedCellsType(const LinkedCellsType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      domain_(x.domain_, f, this),
      r_cutoff_(x.r_cutoff_, f, this),
      boundary_(x.boundary_, f, this) {}

LinkedCellsType::LinkedCellsType(const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      domain_(this),
      r_cutoff_(this),
      boundary_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void LinkedCellsType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                            ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // domain
    //
    if (n.name() == "domain" && n.namespace_().empty()) {
      ::std::auto_ptr<domain_type> r(domain_traits::create(i, f, this));

      if (!domain_.present()) {
        this->domain_.set(r);
        continue;
      }
    }

    // r_cutoff
    //
    if (n.name() == "r_cutoff" && n.namespace_().empty()) {
      if (!r_cutoff_.present()) {
        this->r_cutoff_.set(r_cutoff_traits::create(i, f, this));
        continue;
      }
    }

    // boundary
    //
    if (n.name() == "boundary" && n.namespace_().empty()) {
      ::std::auto_ptr<boundary_type> r(boundary_traits::create(i, f, this));

      if (!boundary_.present()) {
        this->boundary_.set(r);
        continue;
      }
    }

    break;
  }

  if (!domain_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("domain", "");
  }

  if (!r_cutoff_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("r_cutoff", "");
  }

  if (!boundary_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("boundary", "");
  }
}

LinkedCellsType* LinkedCellsType::_clone(::xml_schema::flags f,
                                         ::xml_schema::container* c) const {
  return new class LinkedCellsType(*this, f, c);
}

LinkedCellsType& LinkedCellsType::operator=(const LinkedCellsType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->domain_ = x.domain_;
    this->r_cutoff_ = x.r_cutoff_;
    this->boundary_ = x.boundary_;
  }

  return *this;
}

LinkedCellsType::~LinkedCellsType() {}

// DirectSumType
//

DirectSumType::DirectSumType() : ::xml_schema::type() {}

DirectSumType::DirectSumType(const DirectSumType& x, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

DirectSumType::DirectSumType(const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

DirectSumType::DirectSumType(const ::xercesc::DOMAttr& a, ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

DirectSumType::DirectSumType(const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

DirectSumType* DirectSumType::_clone(::xml_schema::flags f,
                                     ::xml_schema::container* c) const {
  return new class DirectSumType(*this, f, c);
}

DirectSumType::~DirectSumType() {}

// BoundaryType
//

BoundaryType::BoundaryType()
    : ::xml_schema::type(),
      Outflow_(this),
      Reflective_(this),
      Periodic_(this) {}

BoundaryType::BoundaryType(const BoundaryType& x, ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      Outflow_(x.Outflow_, f, this),
      Reflective_(x.Reflective_, f, this),
      Periodic_(x.Periodic_, f, this) {}

BoundaryType::BoundaryType(const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      Outflow_(this),
      Reflective_(this),
      Periodic_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void BoundaryType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Outflow
    //
    if (n.name() == "Outflow" && n.namespace_().empty()) {
      ::std::auto_ptr<Outflow_type> r(Outflow_traits::create(i, f, this));

      if (!this->Outflow_) {
        this->Outflow_.set(r);
        continue;
      }
    }

    // Reflective
    //
    if (n.name() == "Reflective" && n.namespace_().empty()) {
      ::std::auto_ptr<Reflective_type> r(Reflective_traits::create(i, f, this));

      if (!this->Reflective_) {
        this->Reflective_.set(r);
        continue;
      }
    }

    // Periodic
    //
    if (n.name() == "Periodic" && n.namespace_().empty()) {
      ::std::auto_ptr<Periodic_type> r(Periodic_traits::create(i, f, this));

      if (!this->Periodic_) {
        this->Periodic_.set(r);
        continue;
      }
    }

    break;
  }
}

BoundaryType* BoundaryType::_clone(::xml_schema::flags f,
                                   ::xml_schema::container* c) const {
  return new class BoundaryType(*this, f, c);
}

BoundaryType& BoundaryType::operator=(const BoundaryType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Outflow_ = x.Outflow_;
    this->Reflective_ = x.Reflective_;
    this->Periodic_ = x.Periodic_;
  }

  return *this;
}

BoundaryType::~BoundaryType() {}

// BoundaryConfigType
//

BoundaryConfigType::BoundaryConfigType(const x_high_type& x_high,
                                       const x_low_type& x_low,
                                       const y_high_type& y_high,
                                       const y_low_type& y_low,
                                       const z_high_type& z_high,
                                       const z_low_type& z_low)
    : ::xml_schema::type(),
      x_high_(x_high, this),
      x_low_(x_low, this),
      y_high_(y_high, this),
      y_low_(y_low, this),
      z_high_(z_high, this),
      z_low_(z_low, this) {}

BoundaryConfigType::BoundaryConfigType(::std::auto_ptr<x_high_type> x_high,
                                       ::std::auto_ptr<x_low_type> x_low,
                                       ::std::auto_ptr<y_high_type> y_high,
                                       ::std::auto_ptr<y_low_type> y_low,
                                       ::std::auto_ptr<z_high_type> z_high,
                                       ::std::auto_ptr<z_low_type> z_low)
    : ::xml_schema::type(),
      x_high_(x_high, this),
      x_low_(x_low, this),
      y_high_(y_high, this),
      y_low_(y_low, this),
      z_high_(z_high, this),
      z_low_(z_low, this) {}

BoundaryConfigType::BoundaryConfigType(const BoundaryConfigType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      x_high_(x.x_high_, f, this),
      x_low_(x.x_low_, f, this),
      y_high_(x.y_high_, f, this),
      y_low_(x.y_low_, f, this),
      z_high_(x.z_high_, f, this),
      z_low_(x.z_low_, f, this) {}

BoundaryConfigType::BoundaryConfigType(const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      x_high_(this),
      x_low_(this),
      y_high_(this),
      y_low_(this),
      z_high_(this),
      z_low_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void BoundaryConfigType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                               ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // x_high
    //
    if (n.name() == "x_high" && n.namespace_().empty()) {
      ::std::auto_ptr<x_high_type> r(x_high_traits::create(i, f, this));

      if (!x_high_.present()) {
        this->x_high_.set(r);
        continue;
      }
    }

    // x_low
    //
    if (n.name() == "x_low" && n.namespace_().empty()) {
      ::std::auto_ptr<x_low_type> r(x_low_traits::create(i, f, this));

      if (!x_low_.present()) {
        this->x_low_.set(r);
        continue;
      }
    }

    // y_high
    //
    if (n.name() == "y_high" && n.namespace_().empty()) {
      ::std::auto_ptr<y_high_type> r(y_high_traits::create(i, f, this));

      if (!y_high_.present()) {
        this->y_high_.set(r);
        continue;
      }
    }

    // y_low
    //
    if (n.name() == "y_low" && n.namespace_().empty()) {
      ::std::auto_ptr<y_low_type> r(y_low_traits::create(i, f, this));

      if (!y_low_.present()) {
        this->y_low_.set(r);
        continue;
      }
    }

    // z_high
    //
    if (n.name() == "z_high" && n.namespace_().empty()) {
      ::std::auto_ptr<z_high_type> r(z_high_traits::create(i, f, this));

      if (!z_high_.present()) {
        this->z_high_.set(r);
        continue;
      }
    }

    // z_low
    //
    if (n.name() == "z_low" && n.namespace_().empty()) {
      ::std::auto_ptr<z_low_type> r(z_low_traits::create(i, f, this));

      if (!z_low_.present()) {
        this->z_low_.set(r);
        continue;
      }
    }

    break;
  }

  if (!x_high_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x_high", "");
  }

  if (!x_low_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("x_low", "");
  }

  if (!y_high_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y_high", "");
  }

  if (!y_low_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("y_low", "");
  }

  if (!z_high_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z_high", "");
  }

  if (!z_low_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("z_low", "");
  }
}

BoundaryConfigType* BoundaryConfigType::_clone(
    ::xml_schema::flags f, ::xml_schema::container* c) const {
  return new class BoundaryConfigType(*this, f, c);
}

BoundaryConfigType& BoundaryConfigType::operator=(const BoundaryConfigType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->x_high_ = x.x_high_;
    this->x_low_ = x.x_low_;
    this->y_high_ = x.y_high_;
    this->y_low_ = x.y_low_;
    this->z_high_ = x.z_high_;
    this->z_low_ = x.z_low_;
  }

  return *this;
}

BoundaryConfigType::~BoundaryConfigType() {}

// ForceType
//

ForceType::ForceType()
    : ::xml_schema::type(),
      Gravity_(this),
      LennardJones_(this),
      SingularGravity_(this),
      HarmonicForce_(this) {}

ForceType::ForceType(const ForceType& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      Gravity_(x.Gravity_, f, this),
      LennardJones_(x.LennardJones_, f, this),
      SingularGravity_(x.SingularGravity_, f, this),
      HarmonicForce_(x.HarmonicForce_, f, this) {}

ForceType::ForceType(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      Gravity_(this),
      LennardJones_(this),
      SingularGravity_(this),
      HarmonicForce_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ForceType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // Gravity
    //
    if (n.name() == "Gravity" && n.namespace_().empty()) {
      ::std::auto_ptr<Gravity_type> r(Gravity_traits::create(i, f, this));

      if (!this->Gravity_) {
        this->Gravity_.set(r);
        continue;
      }
    }

    // LennardJones
    //
    if (n.name() == "LennardJones" && n.namespace_().empty()) {
      ::std::auto_ptr<LennardJones_type> r(
          LennardJones_traits::create(i, f, this));

      if (!this->LennardJones_) {
        this->LennardJones_.set(r);
        continue;
      }
    }

    // SingularGravity
    //
    if (n.name() == "SingularGravity" && n.namespace_().empty()) {
      ::std::auto_ptr<SingularGravity_type> r(
          SingularGravity_traits::create(i, f, this));

      if (!this->SingularGravity_) {
        this->SingularGravity_.set(r);
        continue;
      }
    }

    // HarmonicForce
    //
    if (n.name() == "HarmonicForce" && n.namespace_().empty()) {
      ::std::auto_ptr<HarmonicForce_type> r(
          HarmonicForce_traits::create(i, f, this));

      if (!this->HarmonicForce_) {
        this->HarmonicForce_.set(r);
        continue;
      }
    }

    break;
  }
}

ForceType* ForceType::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class ForceType(*this, f, c);
}

ForceType& ForceType::operator=(const ForceType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->Gravity_ = x.Gravity_;
    this->LennardJones_ = x.LennardJones_;
    this->SingularGravity_ = x.SingularGravity_;
    this->HarmonicForce_ = x.HarmonicForce_;
  }

  return *this;
}

ForceType::~ForceType() {}

// GravityType
//

GravityType::GravityType() : ::xml_schema::type() {}

GravityType::GravityType(const GravityType& x, ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

GravityType::GravityType(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

GravityType::GravityType(const ::xercesc::DOMAttr& a, ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

GravityType::GravityType(const ::std::string& s, const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

GravityType* GravityType::_clone(::xml_schema::flags f,
                                 ::xml_schema::container* c) const {
  return new class GravityType(*this, f, c);
}

GravityType::~GravityType() {}

// LennardJonesForce
//

LennardJonesForce::LennardJonesForce() : ::xml_schema::type() {}

LennardJonesForce::LennardJonesForce(const LennardJonesForce& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

LennardJonesForce::LennardJonesForce(const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

LennardJonesForce::LennardJonesForce(const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

LennardJonesForce::LennardJonesForce(const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

LennardJonesForce* LennardJonesForce::_clone(::xml_schema::flags f,
                                             ::xml_schema::container* c) const {
  return new class LennardJonesForce(*this, f, c);
}

LennardJonesForce::~LennardJonesForce() {}

// SingularGravityType
//

SingularGravityType::SingularGravityType() : ::xml_schema::type(), g_(this) {}

SingularGravityType::SingularGravityType(const SingularGravityType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), g_(x.g_, f, this) {}

SingularGravityType::SingularGravityType(const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), g_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void SingularGravityType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                                ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr& i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "g" && n.namespace_().empty()) {
      this->g_.set(g_traits::create(i, f, this));
      continue;
    }
  }
}

SingularGravityType* SingularGravityType::_clone(
    ::xml_schema::flags f, ::xml_schema::container* c) const {
  return new class SingularGravityType(*this, f, c);
}

SingularGravityType& SingularGravityType::operator=(
    const SingularGravityType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->g_ = x.g_;
  }

  return *this;
}

SingularGravityType::~SingularGravityType() {}

// HarmonicForceType
//

HarmonicForceType::HarmonicForceType(const r_0_type& r_0, const k_type& k)
    : ::xml_schema::type(), r_0_(r_0, this), k_(k, this) {}

HarmonicForceType::HarmonicForceType(const HarmonicForceType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), r_0_(x.r_0_, f, this), k_(x.k_, f, this) {}

HarmonicForceType::HarmonicForceType(const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      r_0_(this),
      k_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void HarmonicForceType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                              ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // r_0
    //
    if (n.name() == "r_0" && n.namespace_().empty()) {
      if (!r_0_.present()) {
        this->r_0_.set(r_0_traits::create(i, f, this));
        continue;
      }
    }

    // k
    //
    if (n.name() == "k" && n.namespace_().empty()) {
      if (!k_.present()) {
        this->k_.set(k_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!r_0_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("r_0", "");
  }

  if (!k_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("k", "");
  }
}

HarmonicForceType* HarmonicForceType::_clone(::xml_schema::flags f,
                                             ::xml_schema::container* c) const {
  return new class HarmonicForceType(*this, f, c);
}

HarmonicForceType& HarmonicForceType::operator=(const HarmonicForceType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->r_0_ = x.r_0_;
    this->k_ = x.k_;
  }

  return *this;
}

HarmonicForceType::~HarmonicForceType() {}

// ThermostatType
//

ThermostatType::ThermostatType(const T_init_type& T_init,
                               const n_thermostat_type& n_thermostat)
    : ::xml_schema::type(),
      T_init_(T_init, this),
      n_thermostat_(n_thermostat, this),
      T_target_(this),
      deltaT_(this) {}

ThermostatType::ThermostatType(const ThermostatType& x, ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      T_init_(x.T_init_, f, this),
      n_thermostat_(x.n_thermostat_, f, this),
      T_target_(x.T_target_, f, this),
      deltaT_(x.deltaT_, f, this) {}

ThermostatType::ThermostatType(const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      T_init_(this),
      n_thermostat_(this),
      T_target_(this),
      deltaT_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ThermostatType::parse(::xsd::cxx::xml::dom::parser<char>& p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // T_init
    //
    if (n.name() == "T_init" && n.namespace_().empty()) {
      if (!T_init_.present()) {
        this->T_init_.set(T_init_traits::create(i, f, this));
        continue;
      }
    }

    // n_thermostat
    //
    if (n.name() == "n_thermostat" && n.namespace_().empty()) {
      if (!n_thermostat_.present()) {
        this->n_thermostat_.set(n_thermostat_traits::create(i, f, this));
        continue;
      }
    }

    // T_target
    //
    if (n.name() == "T_target" && n.namespace_().empty()) {
      if (!this->T_target_) {
        this->T_target_.set(T_target_traits::create(i, f, this));
        continue;
      }
    }

    // deltaT
    //
    if (n.name() == "deltaT" && n.namespace_().empty()) {
      if (!this->deltaT_) {
        this->deltaT_.set(deltaT_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!T_init_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("T_init", "");
  }

  if (!n_thermostat_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("n_thermostat", "");
  }
}

ThermostatType* ThermostatType::_clone(::xml_schema::flags f,
                                       ::xml_schema::container* c) const {
  return new class ThermostatType(*this, f, c);
}

ThermostatType& ThermostatType::operator=(const ThermostatType& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->T_init_ = x.T_init_;
    this->n_thermostat_ = x.n_thermostat_;
    this->T_target_ = x.T_target_;
    this->deltaT_ = x.deltaT_;
  }

  return *this;
}

ThermostatType::~ThermostatType() {}

// simulation
//

simulation::simulation(const metadata_type& metadata)
    : ::xml_schema::type(),
      metadata_(metadata, this),
      cuboids_(this),
      spheroids_(this),
      thermostat_(this) {}

simulation::simulation(::std::auto_ptr<metadata_type> metadata)
    : ::xml_schema::type(),
      metadata_(metadata, this),
      cuboids_(this),
      spheroids_(this),
      thermostat_(this) {}

simulation::simulation(const simulation& x, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      metadata_(x.metadata_, f, this),
      cuboids_(x.cuboids_, f, this),
      spheroids_(x.spheroids_, f, this),
      thermostat_(x.thermostat_, f, this) {}

simulation::simulation(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      metadata_(this),
      cuboids_(this),
      spheroids_(this),
      thermostat_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void simulation::parse(::xsd::cxx::xml::dom::parser<char>& p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // metadata
    //
    if (n.name() == "metadata" && n.namespace_().empty()) {
      ::std::auto_ptr<metadata_type> r(metadata_traits::create(i, f, this));

      if (!metadata_.present()) {
        this->metadata_.set(r);
        continue;
      }
    }

    // cuboids
    //
    if (n.name() == "cuboids" && n.namespace_().empty()) {
      ::std::auto_ptr<cuboids_type> r(cuboids_traits::create(i, f, this));

      if (!this->cuboids_) {
        this->cuboids_.set(r);
        continue;
      }
    }

    // spheroids
    //
    if (n.name() == "spheroids" && n.namespace_().empty()) {
      ::std::auto_ptr<spheroids_type> r(spheroids_traits::create(i, f, this));

      if (!this->spheroids_) {
        this->spheroids_.set(r);
        continue;
      }
    }

    // thermostat
    //
    if (n.name() == "thermostat" && n.namespace_().empty()) {
      ::std::auto_ptr<thermostat_type> r(thermostat_traits::create(i, f, this));

      if (!this->thermostat_) {
        this->thermostat_.set(r);
        continue;
      }
    }

    break;
  }

  if (!metadata_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("metadata", "");
  }
}

simulation* simulation::_clone(::xml_schema::flags f,
                               ::xml_schema::container* c) const {
  return new class simulation(*this, f, c);
}

simulation& simulation::operator=(const simulation& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->metadata_ = x.metadata_;
    this->cuboids_ = x.cuboids_;
    this->spheroids_ = x.spheroids_;
    this->thermostat_ = x.thermostat_;
  }

  return *this;
}

simulation::~simulation() {}

// cuboids
//

cuboids::cuboids() : ::xml_schema::type(), cuboid_(this) {}

cuboids::cuboids(const cuboids& x, ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), cuboid_(x.cuboid_, f, this) {}

cuboids::cuboids(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), cuboid_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void cuboids::parse(::xsd::cxx::xml::dom::parser<char>& p,
                    ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // cuboid
    //
    if (n.name() == "cuboid" && n.namespace_().empty()) {
      ::std::auto_ptr<cuboid_type> r(cuboid_traits::create(i, f, this));

      this->cuboid_.push_back(r);
      continue;
    }

    break;
  }
}

cuboids* cuboids::_clone(::xml_schema::flags f,
                         ::xml_schema::container* c) const {
  return new class cuboids(*this, f, c);
}

cuboids& cuboids::operator=(const cuboids& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->cuboid_ = x.cuboid_;
  }

  return *this;
}

cuboids::~cuboids() {}

// spheroids
//

spheroids::spheroids() : ::xml_schema::type(), spheroid_(this) {}

spheroids::spheroids(const spheroids& x, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), spheroid_(x.spheroid_, f, this) {}

spheroids::spheroids(const ::xercesc::DOMElement& e, ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), spheroid_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void spheroids::parse(::xsd::cxx::xml::dom::parser<char>& p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement& i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
        ::xsd::cxx::xml::dom::name<char>(i));

    // spheroid
    //
    if (n.name() == "spheroid" && n.namespace_().empty()) {
      ::std::auto_ptr<spheroid_type> r(spheroid_traits::create(i, f, this));

      this->spheroid_.push_back(r);
      continue;
    }

    break;
  }
}

spheroids* spheroids::_clone(::xml_schema::flags f,
                             ::xml_schema::container* c) const {
  return new class spheroids(*this, f, c);
}

spheroids& spheroids::operator=(const spheroids& x) {
  if (this != &x) {
    static_cast< ::xml_schema::type&>(*this) = x;
    this->spheroid_ = x.spheroid_;
  }

  return *this;
}

spheroids::~spheroids() {}

#include <istream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/sax/std-input-source.hxx>

::std::auto_ptr< ::simulation> simulation_(const ::std::string& u,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(const ::std::string& u,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(const ::std::string& u,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::simulation_(isrc, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::simulation_(isrc, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::std::istream& is,
                                           const ::std::string& sid,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::simulation_(isrc, h, f, p);
}

::std::auto_ptr< ::simulation> simulation_(::xercesc::InputSource& i,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(::xercesc::InputSource& i,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(::xercesc::InputSource& i,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::auto_ptr< ::simulation>(
      ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation> simulation_(const ::xercesc::DOMDocument& doc,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p) {
  if (f & ::xml_schema::flags::keep_dom) {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
        static_cast< ::xercesc::DOMDocument*>(doc.cloneNode(true)));

    return ::std::auto_ptr< ::simulation>(
        ::simulation_(d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e(*doc.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "simulation" && n.namespace_() == "") {
    ::std::auto_ptr< ::simulation> r(
        ::xsd::cxx::tree::traits< ::simulation, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "simulation", "");
}

::std::auto_ptr< ::simulation> simulation_(
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d,
    ::xml_schema::flags f, const ::xml_schema::properties&) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> c(
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument*>(d->cloneNode(true))
          : 0);

  ::xercesc::DOMDocument& doc(c.get() ? *c : *d);
  const ::xercesc::DOMElement& e(*doc.getDocumentElement());

  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData(::xml_schema::dom::tree_node_key, (c.get() ? &c : &d), 0);

  if (n.name() == "simulation" && n.namespace_() == "") {
    ::std::auto_ptr< ::simulation> r(
        ::xsd::cxx::tree::traits< ::simulation, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "simulation", "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void simulation_(::std::ostream& o, const ::simulation& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e, ::xml_schema::flags f) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::simulation_(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed< ::xsd::cxx::tree::serialization<char> >();
  }
}

void simulation_(::std::ostream& o, const ::simulation& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e, ::xml_schema::flags f) {
  ::xsd::cxx::xml::auto_initializer i(
      (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::simulation_(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void simulation_(::std::ostream& o, const ::simulation& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e, ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::simulation_(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void simulation_(::xercesc::XMLFormatTarget& t, const ::simulation& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e, ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::simulation_(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed< ::xsd::cxx::tree::serialization<char> >();
  }
}

void simulation_(::xercesc::XMLFormatTarget& t, const ::simulation& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e, ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::simulation_(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void simulation_(::xercesc::XMLFormatTarget& t, const ::simulation& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e, ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::simulation_(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void simulation_(::xercesc::DOMDocument& d, const ::simulation& s,
                 ::xml_schema::flags) {
  ::xercesc::DOMElement& e(*d.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "simulation" && n.namespace_() == "") {
    e << s;
  } else {
    throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                     "simulation", "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> simulation_(
    const ::simulation& s, const ::xml_schema::namespace_infomap& m,
    ::xml_schema::flags f) {
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument> d(
      ::xsd::cxx::xml::dom::serialize<char>("simulation", "", m, f));

  ::simulation_(*d, s, f);
  return d;
}

void operator<<(::xercesc::DOMElement& e, const MetadataType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // container
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("container", e));

    s << i.container();
  }

  // force
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("force", e));

    s << i.force();
  }

  // delta_t
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("delta_t", e));

    s << ::xml_schema::as_decimal(i.delta_t());
  }

  // t_end
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("t_end", e));

    s << ::xml_schema::as_double(i.t_end());
  }

  // twoD
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("twoD", e));

    s << i.twoD();
  }

  // checkpoint
  //
  if (i.checkpoint()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("checkpoint", e));

    s << *i.checkpoint();
  }
}

void operator<<(::xercesc::DOMElement& e, const cuboidType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // velocity
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("velocity", e));

    s << i.velocity();
  }

  // corner
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("corner", e));

    s << i.corner();
  }

  // dimensions
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("dimensions", e));

    s << i.dimensions();
  }

  // type
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("type", e));

    s << i.type();
  }

  // h
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("h", e));

    s << ::xml_schema::as_decimal(i.h());
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("mass", e));

    s << ::xml_schema::as_decimal(i.mass());
  }

  // epsilon
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("epsilon", e));

    s << ::xml_schema::as_decimal(i.epsilon());
  }

  // sigma
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("sigma", e));

    s << ::xml_schema::as_decimal(i.sigma());
  }

  // mv
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("mv", e));

    s << ::xml_schema::as_decimal(i.mv());
  }
}

void operator<<(::xercesc::DOMElement& e, const spheroidType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // velocity
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("velocity", e));

    s << i.velocity();
  }

  // origin
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("origin", e));

    s << i.origin();
  }

  // radius
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("radius", e));

    s << i.radius();
  }

  // type
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("type", e));

    s << i.type();
  }

  // h
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("h", e));

    s << ::xml_schema::as_decimal(i.h());
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("mass", e));

    s << ::xml_schema::as_decimal(i.mass());
  }

  // epsilon
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("epsilon", e));

    s << ::xml_schema::as_decimal(i.epsilon());
  }

  // sigma
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("sigma", e));

    s << ::xml_schema::as_decimal(i.sigma());
  }

  // mv
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("mv", e));

    s << ::xml_schema::as_decimal(i.mv());
  }
}

void operator<<(::xercesc::DOMElement& e, const Dvec3Type& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // x
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("x", e));

    s << ::xml_schema::as_decimal(i.x());
  }

  // y
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("y", e));

    s << ::xml_schema::as_decimal(i.y());
  }

  // z
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("z", e));

    s << ::xml_schema::as_decimal(i.z());
  }
}

void operator<<(::xercesc::DOMElement& e, const Ivec3Type& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // x
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("x", e));

    s << i.x();
  }

  // y
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("y", e));

    s << i.y();
  }

  // z
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("z", e));

    s << i.z();
  }
}

void operator<<(::xercesc::DOMElement& e, const ContainerType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // directSum
  //
  if (i.directSum()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("directSum", e));

    s << *i.directSum();
  }

  // linkedCells
  //
  if (i.linkedCells()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("linkedCells", e));

    s << *i.linkedCells();
  }
}

void operator<<(::xercesc::DOMElement& e, const LinkedCellsType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // domain
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("domain", e));

    s << i.domain();
  }

  // r_cutoff
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("r_cutoff", e));

    s << ::xml_schema::as_decimal(i.r_cutoff());
  }

  // boundary
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("boundary", e));

    s << i.boundary();
  }
}

void operator<<(::xercesc::DOMElement& e, const DirectSumType& i) {
  e << static_cast<const ::xml_schema::type&>(i);
}

void operator<<(::xercesc::DOMAttr&, const DirectSumType&) {}

void operator<<(::xml_schema::list_stream&, const DirectSumType&) {}

void operator<<(::xercesc::DOMElement& e, const BoundaryType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // Outflow
  //
  if (i.Outflow()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("Outflow", e));

    s << *i.Outflow();
  }

  // Reflective
  //
  if (i.Reflective()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("Reflective", e));

    s << *i.Reflective();
  }

  // Periodic
  //
  if (i.Periodic()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("Periodic", e));

    s << *i.Periodic();
  }
}

void operator<<(::xercesc::DOMElement& e, const BoundaryConfigType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // x_high
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("x_high", e));

    s << i.x_high();
  }

  // x_low
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("x_low", e));

    s << i.x_low();
  }

  // y_high
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("y_high", e));

    s << i.y_high();
  }

  // y_low
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("y_low", e));

    s << i.y_low();
  }

  // z_high
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("z_high", e));

    s << i.z_high();
  }

  // z_low
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("z_low", e));

    s << i.z_low();
  }
}

void operator<<(::xercesc::DOMElement& e, const ForceType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // Gravity
  //
  if (i.Gravity()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("Gravity", e));

    s << *i.Gravity();
  }

  // LennardJones
  //
  if (i.LennardJones()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("LennardJones", e));

    s << *i.LennardJones();
  }

  // SingularGravity
  //
  if (i.SingularGravity()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("SingularGravity", e));

    s << *i.SingularGravity();
  }

  // HarmonicForce
  //
  if (i.HarmonicForce()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("HarmonicForce", e));

    s << *i.HarmonicForce();
  }
}

void operator<<(::xercesc::DOMElement& e, const GravityType& i) {
  e << static_cast<const ::xml_schema::type&>(i);
}

void operator<<(::xercesc::DOMAttr&, const GravityType&) {}

void operator<<(::xml_schema::list_stream&, const GravityType&) {}

void operator<<(::xercesc::DOMElement& e, const LennardJonesForce& i) {
  e << static_cast<const ::xml_schema::type&>(i);
}

void operator<<(::xercesc::DOMAttr&, const LennardJonesForce&) {}

void operator<<(::xml_schema::list_stream&, const LennardJonesForce&) {}

void operator<<(::xercesc::DOMElement& e, const SingularGravityType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // g
  //
  if (i.g()) {
    ::xercesc::DOMAttr& a(::xsd::cxx::xml::dom::create_attribute("g", e));

    a << ::xml_schema::as_decimal(*i.g());
  }
}

void operator<<(::xercesc::DOMElement& e, const HarmonicForceType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // r_0
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("r_0", e));

    s << ::xml_schema::as_decimal(i.r_0());
  }

  // k
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("k", e));

    s << ::xml_schema::as_decimal(i.k());
  }
}

void operator<<(::xercesc::DOMElement& e, const ThermostatType& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // T_init
  //
  {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("T_init", e));

    s << ::xml_schema::as_decimal(i.T_init());
  }

  // n_thermostat
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("n_thermostat", e));

    s << i.n_thermostat();
  }

  // T_target
  //
  if (i.T_target()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("T_target", e));

    s << ::xml_schema::as_decimal(*i.T_target());
  }

  // deltaT
  //
  if (i.deltaT()) {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("deltaT", e));

    s << ::xml_schema::as_decimal(*i.deltaT());
  }
}

void operator<<(::xercesc::DOMElement& e, const simulation& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // metadata
  //
  {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("metadata", e));

    s << i.metadata();
  }

  // cuboids
  //
  if (i.cuboids()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("cuboids", e));

    s << *i.cuboids();
  }

  // spheroids
  //
  if (i.spheroids()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("spheroids", e));

    s << *i.spheroids();
  }

  // thermostat
  //
  if (i.thermostat()) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("thermostat", e));

    s << *i.thermostat();
  }
}

void operator<<(::xercesc::DOMElement& e, const cuboids& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // cuboid
  //
  for (cuboids::cuboid_const_iterator b(i.cuboid().begin()),
       n(i.cuboid().end());
       b != n; ++b) {
    ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("cuboid", e));

    s << *b;
  }
}

void operator<<(::xercesc::DOMElement& e, const spheroids& i) {
  e << static_cast<const ::xml_schema::type&>(i);

  // spheroid
  //
  for (spheroids::spheroid_const_iterator b(i.spheroid().begin()),
       n(i.spheroid().end());
       b != n; ++b) {
    ::xercesc::DOMElement& s(
        ::xsd::cxx::xml::dom::create_element("spheroid", e));

    s << *b;
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.
